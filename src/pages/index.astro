---
import '../styles/global.css';
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>‚àû</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">
  </head>
  <body class="bg-black overflow-hidden select-none m-0 p-0">
    <!-- Background elements -->
    <div id="noise" class="fixed inset-0 opacity-5 mix-blend-overlay pointer-events-none"></div>
    <canvas id="stars" class="fixed inset-0 w-full h-full pointer-events-none"></canvas>
    
    <!-- Layer 1 Canvas for Snake/Lemniscate -->
    <div id="layer1-canvas-container" class="fixed inset-0 w-full h-full pointer-events-none" style="z-index: 2;">
      <canvas id="layer1-canvas"></canvas>
    </div>
    
    <!-- Runes Layer for Layer 1 -->
    <div id="runes-layer" class="rune-container"></div>
    
    <!-- Bloom orbs -->
    <div class="bloom-orb bloom-1"></div>
    <div class="bloom-orb bloom-2"></div>
    <div class="bloom-orb bloom-3"></div>
    
    <!-- FX overlays -->
    <div id="warp-glow" class="warp-glow"></div>
    <div id="rift-slit" class="rift-slit"></div>
    <div id="vignette" class="vignette"></div>

    <!-- Layer container -->
    <div id="drift-container" class="fixed inset-0">
      <div id="portal" class="relative w-full h-full">
        <!-- Layer 1: Landing/Home - AION Infinity -->
        <div class="layer active" data-layer="1" data-route="/">
          <div class="layer-content">
            <div class="layer-bg layer-bg-void"></div>
            <!-- Background Gradients for Layer 1 -->
            <div class="layer1-gradients">
              <div class="layer1-gradient layer1-gradient-tl"></div>
              <div class="layer1-gradient layer1-gradient-br"></div>
            </div>
            <!-- AION Title Content -->
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <div class="layer1-content">
                <!-- Animated Letter Stage -->
                <div class="l1-title-stage" id="l1-title-stage">
                  <!-- KAIROS (Line 1) -->
                  <span class="l1-title-letter cinzel" style="transform: translate(-180px, -40px);" id="l1-k1">K</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(-110px, -40px);" id="l1-a1">A</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(-50px, -40px);" id="l1-i1">I</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(15px, -40px);" id="l1-r1">R</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(85px, -40px);" id="l1-o1">O</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(150px, -40px);" id="l1-s1">S</span>
                  <!-- CHAIRON (Line 2) -->
                  <span class="l1-title-letter cinzel" style="transform: translate(-210px, 40px);" id="l1-c2">C</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(-150px, 40px);" id="l1-h2">H</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(-90px, 40px);" id="l1-a2">A</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(-30px, 40px);" id="l1-i2">I</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(30px, 40px);" id="l1-r2">R</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(95px, 40px);" id="l1-o2">O</span>
                  <span class="l1-title-letter cinzel" style="transform: translate(165px, 40px);" id="l1-n2">N</span>
                  <!-- Subtitle -->
                  <div class="l1-title-sub" id="l1-title-manifesto">Eternal Moments</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Layer 2: Writings -->
        <div class="layer" data-layer="2" data-route="/writings">
          <div class="layer-content">
            <div class="layer-bg layer-bg-monolith"></div>
            <!-- Layer 2 Three.js Canvas Container -->
            <div id="l2-canvas-container"></div>
            <!-- Layer 2 Overlays -->
            <div class="l2-scanlines"></div>
            <div class="l2-glitch-noise"></div>
            <div class="l2-vignette"></div>
            <!-- Gate Link -->
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <a href="/writings" class="gate-link" data-gate style="display: flex; flex-direction: column; align-items: center;">
                <span class="layer2-title cinzel">Writings</span>
                <span class="l2-subtitle cinzel" style="margin-top: 1rem; font-size: clamp(0.75rem, 2vw, 1rem); color: rgba(255, 255, 255, 0.55); letter-spacing: 0.1em; text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);">There is something testamentary as if you are already dead in every writing.</span>
              </a>
            </div>
          </div>
        </div>

        <!-- Layer 3: Fragments -->
        <div class="layer" data-layer="3" data-route="/fragments">
          <div class="layer-content">
            <div class="layer-bg layer-bg-debris"></div>
            <!-- Layer 3 Crystalline Sphere Canvas -->
            <div id="layer3-canvas-container">
              <canvas id="layer3-canvas"></canvas>
            </div>
            <!-- Layer 3 Overlays -->
            <div class="layer3-noise"></div>
            <div class="layer3-vignette"></div>
            <div class="layer3-crt"></div>
            <!-- Gate Link -->
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <a href="/fragments" class="gate-link" data-gate>
                <span class="layer3-title cinzel">Fragments</span>
              </a>
            </div>
          </div>
        </div>

        <!-- Layer 4: Message -->
        <div class="layer" data-layer="4" data-route="/message">
          <div class="layer-content">
            <div class="layer-bg layer-bg-beacon"></div>
            <!-- Layer 4 Canvas Container -->
            <div id="l4-canvas-container">
              <canvas id="l4-pond-canvas"></canvas>
            </div>
            <!-- Layer 4 Overlays -->
            <div class="l4-vignette"></div>
            <div class="l4-grain"></div>
            <!-- Gate Link -->
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <a href="/message" class="gate-link" data-gate>
                <span class="layer4-title cinzel">Message</span>
              </a>
            </div>
          </div>
        </div>

        <!-- Layer 5: Music / ORPHEUS -->
        <div class="layer" data-layer="5" data-route="/music">
          <div class="layer-content">
            <div class="layer-bg layer-bg-orpheus"></div>
            <!-- Layer 5 3D Canvas Container -->
            <div id="l5-canvas-container">
              <canvas id="l5-tube-canvas"></canvas>
            </div>
            <!-- Layer 5 Overlays -->
            <div class="l5-grain"></div>
            <div class="l5-vignette"></div>
            <!-- Gate Link -->
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <div class="flex flex-col items-center">
                <a href="/music" class="gate-link l5-title-link" data-gate>
                  <h1 class="layer5-title cinzel">ORPHEUS</h1>
                </a>
                <div class="l5-divider"></div>
                <p class="l5-subtitle">Frequency of the cosmos for itself</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <style>
      :root {
        --warm-white: #F5F2EA;
        --warm-white-dim: rgba(245, 242, 234, 0.5);
        --warm-white-glow: rgba(245, 242, 234, 0.15);
      }

      /* Noise texture */
      #noise {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      }

      /* Bloom orbs */
      .bloom-orb {
        position: absolute;
        border-radius: 50%;
        filter: blur(100px);
        opacity: 0;
        transition: opacity 1.5s ease, transform 3s ease;
      }
      .bloom-1 {
        width: 500px; height: 500px;
        background: radial-gradient(circle, rgba(245,242,234,0.08) 0%, transparent 70%);
        top: 20%; left: 10%;
      }
      .bloom-2 {
        width: 400px; height: 400px;
        background: radial-gradient(circle, rgba(245,242,234,0.06) 0%, transparent 70%);
        bottom: 20%; right: 15%;
      }
      .bloom-3 {
        width: 450px; height: 450px;
        background: radial-gradient(circle, rgba(245,242,234,0.07) 0%, transparent 70%);
        top: 50%; left: 50%; transform: translate(-50%, -50%);
      }
      body.layer-2 .bloom-1 { opacity: 1; }
      body.layer-3 .bloom-2 { opacity: 1; }
      body.layer-4 .bloom-3 { opacity: 1; }
      body.transitioning .bloom-orb { opacity: 0.3; transform: scale(1.5); }

      /* Layer 1 canvas visibility */
      #layer1-canvas-container {
        opacity: 1;
        transition: opacity 0.8s ease;
      }
      body:not(.layer-1) #layer1-canvas-container {
        opacity: 0;
        pointer-events: none;
      }
      
      #layer1-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* Cinzel font family */
      .cinzel {
        font-family: 'Cinzel', serif;
      }

      /* Runes container and animation */
      .rune-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 3;
        width: 100%;
        height: 100%;
        max-width: 80rem;
        opacity: 1;
        transition: opacity 0.8s ease;
      }
      body:not(.layer-1) .rune-container {
        opacity: 0;
        pointer-events: none;
      }

      @keyframes pulse-rune {
        0%, 100% { opacity: 0.3; filter: drop-shadow(0 0 2px cyan); }
        50% { opacity: 0.8; filter: drop-shadow(0 0 8px cyan); }
      }

      .rune {
        position: absolute;
        font-size: 1.2rem;
        color: rgba(200, 250, 255, 0.6);
        animation: pulse-rune 4s infinite ease-in-out;
        font-family: 'Cinzel', serif;
      }

      /* Layer 1 gradients */
      .layer1-gradients {
        position: absolute;
        inset: 0;
        z-index: 0;
        pointer-events: none;
      }
      .layer1-gradient {
        position: absolute;
        border-radius: 50%;
        filter: blur(120px);
      }
      .layer1-gradient-tl {
        top: -10%;
        left: -10%;
        width: 40%;
        height: 40%;
        background: rgba(8, 145, 178, 0.1);
      }
      .layer1-gradient-br {
        bottom: -10%;
        right: -10%;
        width: 40%;
        height: 40%;
        background: rgba(30, 64, 175, 0.1);
      }

      /* Layer 1 title content */
      .layer1-content {
        position: relative;
        z-index: 10;
        text-align: center;
        pointer-events: none;
        user-select: none;
      }

      /* Animated Title Stage */
      .l1-title-stage {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 200px;
        width: 100%;
      }

      .l1-title-letter {
        display: inline-block;
        position: absolute;
        font-size: clamp(3rem, 10vw, 5rem);
        font-weight: 700;
        color: #f8fafc;
        letter-spacing: normal;
        transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        opacity: 0;
      }

      .l1-title-letter.l1-visible {
        opacity: 1;
      }

      .l1-title-letter.l1-hidden {
        opacity: 0;
        transform: scale(0.5);
        pointer-events: none;
      }

      .l1-title-letter.l1-dissolve {
        animation: l1-dissolve-effect 1.5s ease forwards;
      }

      @keyframes l1-dissolve-effect {
        0% {
          opacity: 1;
          filter: blur(0px);
          transform: scale(1);
        }
        50% {
          opacity: 0.5;
          filter: blur(2px);
          transform: scale(1.1);
        }
        100% {
          opacity: 0;
          filter: blur(8px);
          transform: scale(0.3) translateY(-20px);
        }
      }

      .l1-title-letter.l1-aion-final {
        color: #ffffff;
        text-shadow: 0 0 30px rgba(165, 243, 252, 0.5), 0 0 60px rgba(165, 243, 252, 0.2);
      }

      .l1-title-sub {
        position: absolute;
        bottom: -60px;
        font-family: 'EB Garamond', serif;
        font-size: clamp(0.8rem, 2vw, 0.9rem);
        letter-spacing: 0.6em;
        color: rgba(165, 243, 252, 0.4);
        opacity: 0;
        transition: opacity 2s ease;
        text-transform: uppercase;
        white-space: nowrap;
      }

      .l1-title-sub.l1-visible {
        opacity: 1;
      }

      /* Legacy title class kept for compatibility but not used */
      .layer1-title {
        font-size: clamp(3rem, 10vw, 7rem);
        font-weight: 700;
        color: #f8fafc;
        text-shadow: 0 0 20px rgba(165, 243, 252, 0.4), 0 0 40px rgba(165, 243, 252, 0.2);
        letter-spacing: 0.2em;
        margin-bottom: 1rem;
        opacity: 0;
        transition: opacity 1s ease;
      }
      .layer1-title.visible {
        opacity: 1;
      }

      /* Layer 3 title - matches Layer 1 AION exactly */
      .layer3-title {
        font-size: clamp(3rem, 10vw, 7rem);
        font-weight: 700;
        color: #f8fafc;
        text-shadow: 0 0 20px rgba(165, 243, 252, 0.4), 0 0 40px rgba(165, 243, 252, 0.2);
        letter-spacing: 0.2em;
        transition: all 0.6s ease;
      }
      .gate-link:hover .layer3-title {
        text-shadow: 0 0 30px rgba(165, 243, 252, 0.6), 0 0 60px rgba(165, 243, 252, 0.3);
      }

      /* Layer 2 title - matches Layer 1 AION exactly */
      .layer2-title {
        font-size: clamp(3rem, 10vw, 7rem);
        font-weight: 700;
        color: #fff;
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.3);
        letter-spacing: 0.3em;
        text-transform: uppercase;
        transition: all 0.6s ease;
      }
      .gate-link:hover .layer2-title {
        text-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 60px rgba(255, 255, 255, 0.4);
      }

      /* Layer 2 Canvas Container */
      #l2-canvas-container {
        position: absolute;
        inset: 0;
        z-index: 1;
        pointer-events: none;
        filter: contrast(1.2) brightness(1.1);
      }

      /* Layer 2 Scanlines */
      .l2-scanlines {
        position: absolute;
        inset: 0;
        background: linear-gradient(
          to bottom,
          rgba(255,255,255,0),
          rgba(255,255,255,0) 50%,
          rgba(0,0,0,0.2) 50%,
          rgba(0,0,0,0.2)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 10;
      }

      /* Layer 2 Glitch Noise */
      .l2-glitch-noise {
        position: absolute;
        inset: 0;
        opacity: 0.05;
        pointer-events: none;
        z-index: 11;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        animation: l2-noise-anim 0.5s steps(5) infinite;
      }

      @keyframes l2-noise-anim {
        0% { transform: translate(0,0); }
        20% { transform: translate(-5%,-5%); }
        40% { transform: translate(-5%,5%); }
        60% { transform: translate(5%,-5%); }
        80% { transform: translate(5%,5%); }
        100% { transform: translate(0,0); }
      }

      /* Layer 2 Vignette */
      .l2-vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(0,0,0,0) 40%, rgba(0,0,0,1) 100%);
        z-index: 12;
        pointer-events: none;
      }

      .layer1-divider {
        height: 2px;
        width: 6rem;
        background: linear-gradient(to right, transparent, rgba(34, 211, 238, 0.5), transparent);
        margin: 0 auto 1rem auto;
      }

      .layer1-subtitle {
        color: rgba(207, 250, 254, 0.6);
        font-size: clamp(1rem, 3vw, 1.25rem);
        letter-spacing: 0.5em;
        text-transform: uppercase;
        font-weight: 300;
        font-family: 'EB Garamond', serif;
      }

      /* Layer 1 navigation hints */
      .layer1-nav-hints {
        position: absolute;
        bottom: 3rem;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 3rem;
        z-index: 20;
        opacity: 1;
        transition: opacity 0.8s ease;
      }
      body:not(.layer-1) .layer1-nav-hints {
        opacity: 0;
        pointer-events: none;
      }

      .layer1-nav-link {
        font-size: 0.75rem;
        letter-spacing: 0.2em;
        color: rgba(103, 232, 249, 0.3);
        text-decoration: none;
        transition: color 0.3s ease;
      }
      .layer1-nav-link:hover {
        color: rgba(34, 211, 238, 1);
      }

      /* Grain overlay for Layer 1 */
      .layer1-grain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.05;
        pointer-events: none;
        z-index: 50;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      /* Gate typography */
      .gate-text {
        font-family: 'Cormorant Garamond', Georgia, serif;
        font-weight: 300;
        font-style: italic;
        color: var(--warm-white);
        text-shadow: 0 0 60px var(--warm-white-glow), 0 0 120px var(--warm-white-glow);
        letter-spacing: 0.05em;
        transition: all 0.6s ease;
      }

      .gate-link {
        display: inline-block;
        cursor: pointer;
        transition: transform 0.6s ease;
      }
      .gate-link:hover {
        transform: scale(1.02);
      }
      .gate-link:hover .gate-text {
        text-shadow: 0 0 80px rgba(245,242,234,0.25), 0 0 160px var(--warm-white-glow);
      }

      /* Layer backgrounds */
      .layer-bg {
        position: absolute;
        inset: 0;
      }
      .layer-bg-void {
        background: radial-gradient(ellipse at center, #080808 0%, #000000 100%);
      }
      .layer-bg-monolith {
        background:
          radial-gradient(ellipse at 30% 70%, rgba(245,242,234,0.03) 0%, transparent 50%),
          radial-gradient(ellipse at center, #060606 0%, #000000 100%);
      }
      .layer-bg-debris {
        background:
          radial-gradient(ellipse at 70% 30%, rgba(245,242,234,0.025) 0%, transparent 50%),
          radial-gradient(ellipse at 30% 80%, rgba(245,242,234,0.02) 0%, transparent 40%),
          radial-gradient(ellipse at center, #050505 0%, #000000 100%);
      }
      .layer-bg-beacon {
        background:
          radial-gradient(ellipse at center, rgba(245,242,234,0.04) 0%, transparent 40%),
          radial-gradient(ellipse at center, #070705 0%, #000000 100%);
      }

      /* Subtle decorative elements */
      .monolith-shapes {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, transparent 48%, rgba(245,242,234,0.01) 50%, transparent 52%);
        pointer-events: none;
      }
      /* Layer 3 Canvas Container */
      #layer3-canvas-container {
        position: absolute;
        inset: 0;
        z-index: 1;
        pointer-events: none;
      }
      #layer3-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* Layer 3 Noise Overlay */
      .layer3-noise {
        position: absolute;
        inset: 0;
        opacity: 0.04;
        z-index: 2;
        pointer-events: none;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      /* Layer 3 Vignette */
      .layer3-vignette {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 5;
        box-shadow: inset 0 0 200px rgba(0,0,0,0.9);
        background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.6) 100%);
      }

      /* Layer 3 CRT Scanline Effect */
      .layer3-crt {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 10;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), 
                    linear-gradient(90deg, rgba(255, 0, 0, 0.02), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.02));
        background-size: 100% 4px, 3px 100%;
        mix-blend-mode: overlay;
      }
      .beacon-rays {
        position: absolute;
        inset: 0;
        background: conic-gradient(from 0deg at 50% 50%,
          transparent 0deg, rgba(245,242,234,0.015) 10deg, transparent 20deg,
          transparent 90deg, rgba(245,242,234,0.015) 100deg, transparent 110deg,
          transparent 180deg, rgba(245,242,234,0.015) 190deg, transparent 200deg,
          transparent 270deg, rgba(245,242,234,0.015) 280deg, transparent 290deg);
        pointer-events: none;
        animation: beacon-rotate 40s linear infinite;
      }
      @keyframes beacon-rotate {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Layer 4 title - matches reference exactly */
      .layer4-title {
        font-size: clamp(3rem, 10vw, 7rem);
        font-weight: 700;
        color: #f8fafc;
        text-shadow: 0 0 25px rgba(255, 255, 255, 0.3), 0 0 50px rgba(165, 243, 252, 0.1);
        letter-spacing: 0.3em;
        text-transform: uppercase;
        transition: all 0.6s ease;
      }
      .gate-link:hover .layer4-title {
        text-shadow: 0 0 35px rgba(255, 255, 255, 0.5), 0 0 70px rgba(165, 243, 252, 0.2);
      }

      /* Layer 4 Canvas Container */
      #l4-canvas-container {
        position: absolute;
        inset: 0;
        z-index: 1;
        pointer-events: none;
      }
      #l4-pond-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* Layer 4 Vignette */
      .l4-vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at center, rgba(15,23,42,0) 0%, rgba(2,6,23,1) 80%);
        z-index: 5;
        pointer-events: none;
      }

      /* Layer 4 Grain */
      .l4-grain {
        position: absolute;
        inset: 0;
        opacity: 0.04;
        pointer-events: none;
        z-index: 50;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      /* ============ LAYER 5: ORPHEUS / MUSIC ============ */
      .layer-bg-orpheus {
        background: radial-gradient(ellipse at center, #080808 0%, #020617 100%);
      }

      /* Layer 5 Canvas Container */
      #l5-canvas-container {
        position: absolute;
        inset: 0;
        z-index: 1;
        pointer-events: none;
      }
      #l5-tube-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        transition: opacity 0.8s ease;
        pointer-events: none;
      }
      body.layer-5 #l5-tube-canvas {
        opacity: 1;
        pointer-events: auto;
      }

      /* Layer 5 Grain */
      .l5-grain {
        position: absolute;
        inset: 0;
        opacity: 0.05;
        pointer-events: none;
        z-index: 50;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      /* Layer 5 Vignette */
      .l5-vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at center, transparent 0%, rgba(2, 6, 23, 0.4) 40%, rgba(2, 6, 23, 0.9) 100%);
        z-index: 2;
        pointer-events: none;
      }

      /* Layer 5 Title - ORPHEUS */
      .layer5-title {
        font-size: clamp(3rem, 10vw, 5rem);
        font-weight: 700;
        color: #f8fafc;
        text-shadow: 0 0 20px rgba(165, 243, 252, 0.3), 0 0 40px rgba(165, 243, 252, 0.1);
        letter-spacing: 0.6em;
        margin-right: -0.6em;
        transition: all 1s cubic-bezier(0.16, 1, 0.3, 1);
      }
      .gate-link:hover .layer5-title,
      .l5-title-link:hover .layer5-title {
        text-shadow: 0 0 30px rgba(165, 243, 252, 0.6), 0 0 60px rgba(165, 243, 252, 0.3);
        color: #fff;
      }

      /* Layer 5 Divider */
      .l5-divider {
        height: 1px;
        width: 6rem;
        background: linear-gradient(to right, transparent, rgba(34, 211, 238, 0.3), transparent);
        margin: 2rem auto 1rem auto;
      }

      /* Layer 5 Subtitle */
      .l5-subtitle {
        color: rgba(207, 250, 254, 0.4);
        font-size: clamp(0.65rem, 2vw, 0.875rem);
        letter-spacing: 0.5em;
        text-transform: uppercase;
        font-weight: 300;
        font-family: 'EB Garamond', serif;
      }

      /* Layer 5 Title Link - only enable pointer events when layer is active */
      .l5-title-link {
        cursor: pointer;
        text-decoration: none;
        color: inherit;
      }

      /* Layer 5 Fade In Animation */
      .layer[data-layer="5"].active .layer5-title,
      .layer[data-layer="5"].active .l5-divider,
      .layer[data-layer="5"].active .l5-subtitle {
        animation: l5-fade-in 2.5s forwards ease-out;
      }
      .layer[data-layer="5"].active .l5-divider {
        animation-delay: 0.5s;
        opacity: 0;
      }
      .layer[data-layer="5"].active .l5-subtitle {
        animation-delay: 0.8s;
        opacity: 0;
      }
      @keyframes l5-fade-in {
        to { opacity: 1; }
      }

      /* Layer base */
      .layer {
        position: absolute;
        inset: 0;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s ease;
      }
      .layer.active {
        opacity: 1;
        pointer-events: auto;
      }
      .layer-content {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        will-change: transform, filter;
      }
      .layer-inner {
        position: relative;
        z-index: 1;
        will-change: transform;
      }

      /* Idle float */
      .layer.active:not(.transitioning) .layer-inner {
        animation: idle-float 10s ease-in-out infinite;
      }
      @keyframes idle-float {
        0%, 100% { transform: translateY(0) scale(1); }
        50% { transform: translateY(-8px) scale(1.002); }
      }

      /* Warp transition - slower, smoother */
      .layer-content.warp-out {
        animation: warp-out 1100ms cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      .layer-content.warp-in {
        animation: warp-in 1100ms cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      @keyframes warp-out {
        0% {
          transform: scale(1) translateZ(0);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
        35% {
          transform: scale(1.4) translateZ(100px);
          filter: blur(3px) brightness(1.2);
          opacity: 0.85;
        }
        70% {
          transform: scale(2.5) translateZ(300px);
          filter: blur(10px) brightness(1.6);
          opacity: 0.4;
        }
        100% {
          transform: scale(4) translateZ(500px);
          filter: blur(16px) brightness(2);
          opacity: 0;
        }
      }
      @keyframes warp-in {
        0% {
          transform: scale(0.15) translateZ(-500px);
          filter: blur(16px) brightness(0.2);
          opacity: 0;
        }
        30% {
          transform: scale(0.5) translateZ(-200px);
          filter: blur(8px) brightness(0.5);
          opacity: 0.4;
        }
        65% {
          transform: scale(0.85) translateZ(-50px);
          filter: blur(2px) brightness(0.9);
          opacity: 0.85;
        }
        100% {
          transform: scale(1) translateZ(0);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
      }

      /* Rift fall transition - slower, more dramatic */
      .layer-content.rift-out {
        animation: rift-out 900ms cubic-bezier(0.55, 0.05, 0.67, 0.19) forwards;
      }
      .layer-content.rift-in {
        animation: rift-in 1100ms cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
      }
      @keyframes rift-out {
        0% {
          transform: translateY(0) rotate(0deg) scale(1);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
        25% {
          transform: translateY(30px) rotate(1deg) scale(0.98);
          filter: blur(1px) brightness(0.8);
          opacity: 0.9;
        }
        60% {
          transform: translateY(150px) rotate(3deg) scale(0.85);
          filter: blur(6px) brightness(0.4);
          opacity: 0.5;
        }
        100% {
          transform: translateY(400px) rotate(6deg) scale(0.6);
          filter: blur(14px) brightness(0.1);
          opacity: 0;
        }
      }
      @keyframes rift-in {
        0% {
          transform: translateY(-400px) rotate(-4deg) scale(0.6);
          filter: blur(14px) brightness(0.1);
          opacity: 0;
        }
        40% {
          transform: translateY(-50px) rotate(-1deg) scale(0.95);
          filter: blur(4px) brightness(0.7);
          opacity: 0.7;
        }
        70% {
          transform: translateY(15px) rotate(0.5deg) scale(1.01);
          filter: blur(1px) brightness(0.95);
          opacity: 0.95;
        }
        85% {
          transform: translateY(-5px) rotate(-0.2deg) scale(1.005);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
        100% {
          transform: translateY(0) rotate(0deg) scale(1);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
      }

      /* FX overlays */
      .warp-glow {
        position: absolute;
        top: 50%; left: 50%;
        width: 0; height: 0;
        background: radial-gradient(circle, rgba(245,242,234,0.6) 0%, rgba(245,242,234,0) 70%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
      }
      .warp-glow.active {
        width: 400px; height: 400px;
        opacity: 0.3;
      }

      .rift-slit {
        position: absolute;
        top: 0; left: 50%;
        width: 3px; height: 100%;
        background: linear-gradient(180deg, transparent 0%, rgba(245,242,234,0.7) 30%, rgba(245,242,234,0.7) 70%, transparent 100%);
        transform: translateX(-50%) scaleY(0);
        opacity: 0;
        filter: blur(2px);
        box-shadow: 0 0 40px 15px rgba(245,242,234,0.2);
      }
      .rift-slit.active {
        animation: rift-slit-flash 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      @keyframes rift-slit-flash {
        0% { transform: translateX(-50%) scaleY(0); opacity: 0; }
        25% { transform: translateX(-50%) scaleY(1); opacity: 1; }
        100% { transform: translateX(-50%) scaleY(0); opacity: 0; }
      }

      .vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.7) 100%);
        opacity: 0;
        transition: opacity 0.6s ease;
      }
      .vignette.active {
        opacity: 1;
      }

      /* Drift container */
      #drift-container {
        transition: transform 0.15s ease-out;
      }

      /* Text shadow fix for warm-white class */
      .text-warm-white {
        color: var(--warm-white);
        text-shadow: 0 0 40px var(--warm-white-glow), 0 0 80px var(--warm-white-glow);
      }
    </style>

    <script>
      // ============ STATE ============
      let currentLayer = 1;
      let isTransitioning = false;
      const totalLayers = 5;

      // Drift state
      const drift = { x: 0, y: 0, vx: 0, vy: 0 };
      const keys = { up: false, down: false, left: false, right: false };
      const driftSpeed = 0.6;
      const driftFriction = 0.94;
      const driftMax = 50;
      const mouseParallax = { x: 0, y: 0 };

      // Star state
      let stars = [];
      let starSpeed = 0.2;
      let targetStarSpeed = 0.2;
      const baseStarSpeed = 0.2;
      const warpStarSpeed = 12;
      const fallStarSpeed = 6;

      // Mobile state
      let longPressTimer = null;
      let touchStartTime = 0;
      const longPressDuration = 600;

      // Double click
      let lastClickTime = 0;
      const doubleClickThreshold = 300;

      // Timing constants (slower)
      const warpDuration = 2200;
      const warpMidpoint = 1100;
      const fallDuration = 2000;
      const fallMidpoint = 900;

      // ============ ELEMENTS ============
      const canvas = document.getElementById('stars');
      const ctx = canvas.getContext('2d');
      const driftContainer = document.getElementById('drift-container');
      const warpGlow = document.getElementById('warp-glow');
      const riftSlit = document.getElementById('rift-slit');
      const vignette = document.getElementById('vignette');

      // ============ CANVAS SETUP ============
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function createStars(count) {
        // Responsive star count based on screen size
        if (!count) {
          const targetCount = Math.min(1200, Math.floor((canvas.width * canvas.height) / 4500));
          count = targetCount;
        }
        stars = [];
        for (let i = 0; i < count; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            z: Math.random() * 1000,
            size: Math.random() * 1 + 0.2,
            brightness: Math.random() * 0.3 + 0.2
          });
        }
      }

      function drawStars() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2 + drift.x * 0.5;
        const centerY = canvas.height / 2 + drift.y * 0.5;

        stars.forEach(star => {
          star.z -= starSpeed * 6;
          if (star.z <= 0) {
            star.z = 1000;
            star.x = Math.random() * canvas.width;
            star.y = Math.random() * canvas.height;
          }

          const scale = 800 / star.z;
          const x = (star.x - centerX) * scale + centerX;
          const y = (star.y - centerY) * scale + centerY;
          const size = Math.max(0.3, star.size * scale * (starSpeed > 2 ? 1 + (starSpeed - 2) * 0.15 : 1));

          // Warm white color
          const warmR = 245, warmG = 242, warmB = 234;

          if (starSpeed > 2) {
            const prevZ = star.z + starSpeed * 6;
            const prevScale = 800 / prevZ;
            const prevX = (star.x - centerX) * prevScale + centerX;
            const prevY = (star.y - centerY) * prevScale + centerY;

            const grad = ctx.createLinearGradient(prevX, prevY, x, y);
            grad.addColorStop(0, `rgba(${warmR},${warmG},${warmB},0)`);
            grad.addColorStop(1, `rgba(${warmR},${warmG},${warmB},${star.brightness * 0.6})`);

            ctx.beginPath();
            ctx.strokeStyle = grad;
            ctx.lineWidth = size * 0.5;
            ctx.moveTo(prevX, prevY);
            ctx.lineTo(x, y);
            ctx.stroke();
          }

          ctx.beginPath();
          ctx.fillStyle = `rgba(${warmR},${warmG},${warmB},${star.brightness})`;
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        });

        // Slower interpolation for smoother feel
        starSpeed += (targetStarSpeed - starSpeed) * 0.04;
      }

      // ============ DRIFT SYSTEM ============
      function updateDrift() {
        if (keys.up) drift.vy -= driftSpeed;
        if (keys.down) drift.vy += driftSpeed;
        if (keys.left) drift.vx -= driftSpeed;
        if (keys.right) drift.vx += driftSpeed;

        drift.vx *= driftFriction;
        drift.vy *= driftFriction;

        drift.x += drift.vx;
        drift.y += drift.vy;

        drift.x = Math.max(-driftMax, Math.min(driftMax, drift.x));
        drift.y = Math.max(-driftMax, Math.min(driftMax, drift.y));

        const finalX = drift.x + mouseParallax.x * 12;
        const finalY = drift.y + mouseParallax.y * 12;

        driftContainer.style.transform = `translate(${finalX}px, ${finalY}px)`;
      }

      // ============ ANIMATION LOOP ============
      function animate() {
        drawStars();
        updateDrift();
        requestAnimationFrame(animate);
      }

      // ============ LAYER TRANSITIONS ============
      function updateLayerClass() {
        document.body.classList.remove('layer-1', 'layer-2', 'layer-3', 'layer-4', 'layer-5');
        document.body.classList.add(`layer-${currentLayer}`);
      }

      function warpTransition(targetLayer) {
        if (isTransitioning || targetLayer < 1 || targetLayer > totalLayers || targetLayer === currentLayer) return;

        console.log(`[WARP] Layer ${currentLayer} -> ${targetLayer}`);
        isTransitioning = true;
        document.body.classList.add('transitioning');

        const currentEl = document.querySelector(`.layer[data-layer="${currentLayer}"]`);
        const targetEl = document.querySelector(`.layer[data-layer="${targetLayer}"]`);
        const currentContent = currentEl.querySelector('.layer-content');
        const targetContent = targetEl.querySelector('.layer-content');

        targetStarSpeed = warpStarSpeed;
        warpGlow.classList.add('active');
        vignette.classList.add('active');

        currentContent.classList.add('warp-out');
        currentEl.classList.add('transitioning');

        setTimeout(() => {
          warpGlow.classList.remove('active');
        }, 600);

        setTimeout(() => {
          currentEl.classList.remove('active');
          currentContent.classList.remove('warp-out');
          targetEl.classList.add('active', 'transitioning');
          targetContent.classList.add('warp-in');
          currentLayer = targetLayer;
          updateLayerClass();
        }, warpMidpoint);

        setTimeout(() => {
          targetContent.classList.remove('warp-in');
          currentEl.classList.remove('transitioning');
          targetEl.classList.remove('transitioning');
          vignette.classList.remove('active');
          targetStarSpeed = baseStarSpeed;
          isTransitioning = false;
          document.body.classList.remove('transitioning');
        }, warpDuration);
      }

      function riftFallTransition() {
        if (isTransitioning || currentLayer === 1) return;

        const options = [2, 3, 4].filter(l => l !== currentLayer);
        const targetLayer = options[Math.floor(Math.random() * options.length)];

        console.log(`[RIFT FALL] Layer ${currentLayer} -> ${targetLayer}`);
        isTransitioning = true;
        document.body.classList.add('transitioning');

        const currentEl = document.querySelector(`.layer[data-layer="${currentLayer}"]`);
        const targetEl = document.querySelector(`.layer[data-layer="${targetLayer}"]`);
        const currentContent = currentEl.querySelector('.layer-content');
        const targetContent = targetEl.querySelector('.layer-content');

        targetStarSpeed = fallStarSpeed;
        riftSlit.classList.add('active');
        vignette.classList.add('active');

        currentContent.classList.add('rift-out');
        currentEl.classList.add('transitioning');

        setTimeout(() => {
          riftSlit.classList.remove('active');
        }, 600);

        setTimeout(() => {
          currentEl.classList.remove('active');
          currentContent.classList.remove('rift-out');
          targetEl.classList.add('active', 'transitioning');
          targetContent.classList.add('rift-in');
          currentLayer = targetLayer;
          updateLayerClass();
        }, fallMidpoint);

        setTimeout(() => {
          targetContent.classList.remove('rift-in');
          currentEl.classList.remove('transitioning');
          targetEl.classList.remove('transitioning');
          vignette.classList.remove('active');
          targetStarSpeed = baseStarSpeed;
          isTransitioning = false;
          document.body.classList.remove('transitioning');
        }, fallDuration);
      }

      function gateTransition(href) {
        if (isTransitioning) return;

        console.log(`[GATE] Navigating to ${href}`);
        isTransitioning = true;
        document.body.classList.add('transitioning');

        targetStarSpeed = warpStarSpeed;
        warpGlow.classList.add('active');

        const layer = document.querySelector('.layer.active');
        const content = layer.querySelector('.layer-content');
        content.classList.add('warp-out');

        setTimeout(() => {
          window.location.href = href;
        }, 800);
      }

      // ============ EVENT HANDLERS ============
      document.addEventListener('keydown', (e) => {
        // Drift keys (do NOT change layers)
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { keys.up = true; e.preventDefault(); }
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { keys.down = true; e.preventDefault(); }
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { keys.left = true; e.preventDefault(); }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { keys.right = true; e.preventDefault(); }

        // Layer change keys
        if (e.key === 'Enter' && !e.repeat) {
          e.preventDefault();
          const nextLayer = (currentLayer % totalLayers) + 1;
          warpTransition(nextLayer);
        }

        if ((e.key === 'f' || e.key === 'F' || e.key === ' ') && !e.repeat) {
          e.preventDefault();
          if (currentLayer === 1) {
            warpTransition(2);
          } else {
            riftFallTransition();
          }
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
      });

      document.addEventListener('mousemove', (e) => {
        mouseParallax.x = (e.clientX / window.innerWidth - 0.5) * 2;
        mouseParallax.y = (e.clientY / window.innerHeight - 0.5) * 2;
      });

      document.addEventListener('click', (e) => {
        if (e.target.closest('[data-gate]')) return;

        const now = Date.now();
        if (now - lastClickTime < doubleClickThreshold) {
          if (currentLayer === 1) {
            warpTransition(2);
          } else {
            riftFallTransition();
          }
        }
        lastClickTime = now;
      });

      document.querySelectorAll('[data-gate]').forEach(gate => {
        gate.addEventListener('click', function(e) {
          e.preventDefault();
          const href = this.getAttribute('href');
          console.log('[GATE] Clicked:', href);
          gateTransition(href);
        });
      });

      // Mobile touch
      document.addEventListener('touchstart', (e) => {
        if (e.target.closest('[data-gate]')) return;

        touchStartTime = Date.now();
        longPressTimer = setTimeout(() => {
          if (currentLayer === 1) {
            warpTransition(2);
          } else {
            riftFallTransition();
          }
        }, longPressDuration);
      }, { passive: true });

      document.addEventListener('touchend', (e) => {
        if (e.target.closest('[data-gate]')) return;

        clearTimeout(longPressTimer);
        const duration = Date.now() - touchStartTime;

        if (duration < longPressDuration) {
          warpTransition(currentLayer + 1);
        }
      }, { passive: true });

      document.addEventListener('touchmove', () => {
        clearTimeout(longPressTimer);
      }, { passive: true });

      // ============ INIT ============
      resizeCanvas();
      createStars();
      updateLayerClass();
      animate();

      window.addEventListener('resize', () => {
        resizeCanvas();
        createStars();
      });

      console.log('[PORTAL] Initialized');
    </script>

    <!-- ============ LAYER 1 LEMNISCATE SNAKE + PARTICLES SYSTEM ============ -->
    <script>
      /**
       * Layer 1 Visual - Lemniscate Snake with Particles and Runes
       */
      (function() {
        const canvas = document.getElementById('layer1-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const runesLayer = document.getElementById('runes-layer');

        let width, height;
        let particles = [];
        let mouse = { x: 0, y: 0, active: false };
        let time = 0;

        // Lemniscate parameters
        const snakeLength = 80;
        const segments = [];

        const RUNE_CHARS = ['·ö†', '·ö¢', '·ö¶', '·ö®', '·ö±', '·ö≤', '·ö∑', '·öπ', '·ö∫', '·öª', '·õÅ', '·õÉ', '·õà', '·õâ', '·õä', '·õã', '·õè', '·õí', '·õñ', '·õó', '·õö', '·õú', '·õü', '·õû', 'êéÄ', 'êéÅ', 'êéÇ', 'êéÉ', 'êéÑ', 'êéÖ'];

        function init() {
          resize();
          window.addEventListener('resize', resize);
          window.addEventListener('mousemove', function(e) {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.active = true;
          });

          // Initialize snake segments
          for (let i = 0; i < snakeLength; i++) {
            segments.push({ x: 0, y: 0 });
          }

          // Generate particles
          const particleCount = window.innerWidth < 768 ? 100 : 200;
          for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
          }

          // Generate runes along the path
          createRunes();

          animate();
        }

        function resize() {
          width = canvas.width = window.innerWidth;
          height = canvas.height = window.innerHeight;
          createRunes();
        }

        // Bernoulli Lemniscate Equation
        function getLemniscatePoint(t, a) {
          const denom = 1 + Math.pow(Math.sin(t), 2);
          return {
            x: (a * Math.cos(t)) / denom + (width / 2),
            y: (a * Math.sin(t) * Math.cos(t)) / denom + (height / 2)
          };
        }

        function createRunes() {
          if (!runesLayer) return;
          runesLayer.innerHTML = '';
          const runeCount = 32;
          const a = Math.min(width, height) * 0.38;
          
          for (let i = 0; i < runeCount; i++) {
            const t = (i / runeCount) * Math.PI * 2;
            const pos = getLemniscatePoint(t, a * 1.2);
            
            const rune = document.createElement('div');
            rune.className = 'rune cinzel';
            rune.innerText = RUNE_CHARS[Math.floor(Math.random() * RUNE_CHARS.length)];
            rune.style.left = pos.x + 'px';
            rune.style.top = pos.y + 'px';
            rune.style.animationDelay = (Math.random() * 5) + 's';
            rune.style.fontSize = (Math.random() * 10 + 15) + 'px';
            runesLayer.appendChild(rune);
          }
        }

        function Particle() {
          this.reset();
        }
        
        Particle.prototype.reset = function() {
          this.x = Math.random() * width;
          this.y = Math.random() * height;
          this.vx = (Math.random() - 0.5) * 0.5;
          this.vy = (Math.random() - 0.5) * 0.5;
          this.size = Math.random() * 2;
          this.alpha = Math.random() * 0.5;
        };
        
        Particle.prototype.update = function() {
          this.x += this.vx;
          this.y += this.vy;
          if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.reset();

          // Interaction with mouse
          if (mouse.active) {
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 150) {
              this.x -= dx * 0.01;
              this.y -= dy * 0.01;
            }
          }
        };
        
        Particle.prototype.draw = function() {
          ctx.fillStyle = 'rgba(165, 243, 252, ' + this.alpha + ')';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        };

        function animate() {
          // Only render if on layer 1
          if (!document.body.classList.contains('layer-1')) {
            requestAnimationFrame(animate);
            return;
          }
          
          ctx.clearRect(0, 0, width, height);
          time += 0.008;

          const a = Math.min(width, height) * 0.38;

          // 1. Draw Static Path (Glow)
          const pathRes = 100;
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(6, 182, 212, 0.05)';
          ctx.lineWidth = 40;
          for (let i = 0; i <= pathRes; i++) {
            const t = (i / pathRes) * Math.PI * 2;
            const p = getLemniscatePoint(t, a);
            if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();

          // 2. Update and Draw Snake
          const headPos = getLemniscatePoint(time, a);
          segments[0] = headPos;

          for (let i = 1; i < snakeLength; i++) {
            const prev = segments[i - 1];
            const curr = segments[i];
            curr.x += (prev.x - curr.x) * 0.35;
            curr.y += (prev.y - curr.y) * 0.35;
          }

          // Draw Body with Stardust Effect
          for (let i = snakeLength - 1; i >= 0; i--) {
            const s = segments[i];
            const size = (1 - i / snakeLength) * 12 + 2;
            const opacity = (1 - i / snakeLength) * 0.8;
            
            if (i > 0) {
              ctx.beginPath();
              ctx.strokeStyle = 'rgba(200, 255, 255, ' + (opacity * 0.4) + ')';
              ctx.lineWidth = size;
              ctx.lineCap = 'round';
              ctx.moveTo(segments[i-1].x, segments[i-1].y);
              ctx.lineTo(s.x, s.y);
              ctx.stroke();
            }

            // Sparkle clusters on body
            if (i % 3 === 0) {
              const sparkCount = Math.floor(size / 3);
              for (let j = 0; j < sparkCount; j++) {
                const ox = (Math.random() - 0.5) * size * 1.5;
                const oy = (Math.random() - 0.5) * size * 1.5;
                ctx.fillStyle = 'rgba(255, 255, 255, ' + (Math.random() * opacity) + ')';
                ctx.beginPath();
                ctx.arc(s.x + ox, s.y + oy, Math.random() * 1.5, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }

          // Head highlight
          ctx.shadowBlur = 25;
          ctx.shadowColor = 'cyan';
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(segments[0].x, segments[0].y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;

          // 3. Draw Ambient Particles
          particles.forEach(function(p) {
            p.update();
            p.draw();
          });

          requestAnimationFrame(animate);
        }

        init();
        console.log('[LAYER1] Lemniscate visual initialized');
      })();
    </script>

    <!-- ============ LAYER 1 TITLE ANIMATION (KAIROS/CHAIRON ‚Üí KAIRON ‚Üí AION) ============ -->
    <script>
      /**
       * Layer 1 Title Animation - KAIROS/CHAIRON merging to KAIRON then AION
       * Pauses when Layer 1 is not active, resumes when returning
       */
      (function() {
        const letters = {
          k1: document.getElementById('l1-k1'),
          a1: document.getElementById('l1-a1'),
          i1: document.getElementById('l1-i1'),
          r1: document.getElementById('l1-r1'),
          o1: document.getElementById('l1-o1'),
          s1: document.getElementById('l1-s1'),
          c2: document.getElementById('l1-c2'),
          h2: document.getElementById('l1-h2'),
          a2: document.getElementById('l1-a2'),
          i2: document.getElementById('l1-i2'),
          r2: document.getElementById('l1-r2'),
          o2: document.getElementById('l1-o2'),
          n2: document.getElementById('l1-n2')
        };
        const manifesto = document.getElementById('l1-title-manifesto');

        // Check if elements exist
        if (!letters.k1) return;

        let animationComplete = false;
        let timeouts = [];

        function wait(ms) {
          return new Promise(resolve => {
            const id = setTimeout(resolve, ms);
            timeouts.push(id);
          });
        }

        function clearAllTimeouts() {
          timeouts.forEach(id => clearTimeout(id));
          timeouts = [];
        }

        async function runSequence() {
          // Reset state
          animationComplete = false;
          clearAllTimeouts();

          // Reset all letters to initial state
          Object.values(letters).forEach(el => {
            if (el) {
              el.classList.remove('l1-visible', 'l1-hidden', 'l1-dissolve', 'l1-aion-final');
              el.style.transform = '';
            }
          });
          if (manifesto) {
            manifesto.classList.remove('l1-visible');
            manifesto.style.opacity = '0';
          }

          // Apply initial positions
          if (letters.k1) letters.k1.style.transform = 'translate(-180px, -40px)';
          if (letters.a1) letters.a1.style.transform = 'translate(-110px, -40px)';
          if (letters.i1) letters.i1.style.transform = 'translate(-50px, -40px)';
          if (letters.r1) letters.r1.style.transform = 'translate(15px, -40px)';
          if (letters.o1) letters.o1.style.transform = 'translate(85px, -40px)';
          if (letters.s1) letters.s1.style.transform = 'translate(150px, -40px)';
          if (letters.c2) letters.c2.style.transform = 'translate(-210px, 40px)';
          if (letters.h2) letters.h2.style.transform = 'translate(-150px, 40px)';
          if (letters.a2) letters.a2.style.transform = 'translate(-90px, 40px)';
          if (letters.i2) letters.i2.style.transform = 'translate(-30px, 40px)';
          if (letters.r2) letters.r2.style.transform = 'translate(30px, 40px)';
          if (letters.o2) letters.o2.style.transform = 'translate(95px, 40px)';
          if (letters.n2) letters.n2.style.transform = 'translate(165px, 40px)';

          // --- STEP 1: Show KAIROS and CHAIRON ---
          await wait(500);
          Object.values(letters).forEach(el => {
            if (el) el.classList.add('l1-visible');
          });
          await wait(2000);

          // Check if still on layer 1
          if (!document.body.classList.contains('layer-1')) return;

          // --- STEP 2: Merge to KAIRON ---
          // Hide extra letters: S, C, H, A2, I2, R2, O2
          ['s1', 'c2', 'h2', 'a2', 'i2', 'r2', 'o2'].forEach(id => {
            if (letters[id]) letters[id].classList.add('l1-hidden');
          });

          // Move first line KAIRO to center (y: 0)
          if (letters.k1) letters.k1.style.transform = 'translate(-180px, 0px)';
          if (letters.a1) letters.a1.style.transform = 'translate(-110px, 0px)';
          if (letters.i1) letters.i1.style.transform = 'translate(-50px, 0px)';
          if (letters.r1) letters.r1.style.transform = 'translate(15px, 0px)';
          if (letters.o1) letters.o1.style.transform = 'translate(85px, 0px)';

          // Move N from line 2 to end of line 1
          if (letters.n2) letters.n2.style.transform = 'translate(155px, 0px)';

          await wait(2500);

          // Check if still on layer 1
          if (!document.body.classList.contains('layer-1')) return;

          // --- STEP 3: Dissolve K and R to form AION ---
          // Apply dissolve effect to K and R
          if (letters.k1) letters.k1.classList.add('l1-dissolve');
          if (letters.r1) letters.r1.classList.add('l1-dissolve');

          // Rearrange A I O N to be centered
          await wait(100);
          if (letters.a1) letters.a1.style.transform = 'translate(-120px, 0px)';
          if (letters.i1) letters.i1.style.transform = 'translate(-40px, 0px)';
          if (letters.o1) letters.o1.style.transform = 'translate(40px, 0px)';
          if (letters.n2) letters.n2.style.transform = 'translate(120px, 0px)';

          // Add final glow effect
          ['a1', 'i1', 'o1', 'n2'].forEach(id => {
            if (letters[id]) letters[id].classList.add('l1-aion-final');
          });

          await wait(1000);

          // Check if still on layer 1
          if (!document.body.classList.contains('layer-1')) return;

          // --- STEP 4: Final positioning with wider spacing ---
          if (letters.a1) letters.a1.style.transform = 'translate(-160px, 0px)';
          if (letters.i1) letters.i1.style.transform = 'translate(-55px, 0px)';
          if (letters.o1) letters.o1.style.transform = 'translate(55px, 0px)';
          if (letters.n2) letters.n2.style.transform = 'translate(160px, 0px)';

          // Show subtitle
          if (manifesto) {
            manifesto.classList.add('l1-visible');
            manifesto.style.opacity = '1';
          }

          animationComplete = true;
          console.log('[LAYER1] Title animation complete');
        }

        // Start animation on load
        runSequence();

        // Handle layer visibility changes - pause/resume
        let wasOnLayer1 = document.body.classList.contains('layer-1');

        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'class') {
              const isOnLayer1 = document.body.classList.contains('layer-1');

              // Coming back to layer 1 - restart animation if not complete
              if (isOnLayer1 && !wasOnLayer1) {
                if (!animationComplete) {
                  runSequence();
                }
              }

              // Leaving layer 1 - clear pending timeouts
              if (!isOnLayer1 && wasOnLayer1) {
                clearAllTimeouts();
              }

              wasOnLayer1 = isOnLayer1;
            }
          });
        });

        observer.observe(document.body, { attributes: true });

        console.log('[LAYER1] Title animation system initialized');
      })();
    </script>

    <!-- ============ LAYER 2 TEXT TUNNEL SYSTEM (THREE.JS) ============ -->
    <script type="module">
      /**
       * Layer 2 Visual - Text Tunnel with Three.js
       * Only runs when Layer 2 is active, pauses otherwise
       */
      import('https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js').then((THREE) => {
        const container = document.getElementById('l2-canvas-container');
        if (!container) return;

        let scene, camera, renderer;
        let sprites = [];
        let particleSystem;
        let animationId = null;
        let isActive = false;
        let time = 0;
        let mouseX = 0, mouseY = 0;

        // Cap DPR for performance
        const dpr = Math.min(window.devicePixelRatio || 1, 1.5);

        // --- DATA CORPUS ---
        const nietzscheQuote = [
          "Dieses Leben", "wie du es jetzt lebst", "und gelebt hast",
          "wirst du noch einmal", "und noch unz√§hlige Male", "leben m√ºssen",
          "jeder Schmerz", "jede Lust", "jeder Gedanke", "jeder Seufzer",
          "Das ewige Sanduhr", "des Daseins"
        ];

        const ancientWords = [
          "AION", "CHRONOS", "KAIROS", "LOGOS", "ARCHE", "APEIRON",
          "MEMENTO MORI", "AMOR FATI", "ETERNALIS", "ABSOLUTUM",
          "L'Absolu", "Le N√©ant", "La Dur√©e", "L'√âlan Vital",
          "Das Ding an sich", "Wille zur Macht", "Dasein",
          "L'Eterno Ritorno", "Il Tempo"
        ];

        const symbols = [
          "‚àë", "‚à´", "‚àÇ", "‚àá", "‚àÄ", "‚àÉ", "‚àû", "‚àÖ", "‚àà", "‚äÇ",
          "Œª", "Œ©", "Œ®", "Œ¶", "‚àÜ", "œÄ", "‚â†", "‚âà",
          "0x00", "NULL", "void*", "i++", "&&", "||", "=>",
          "‚Ä†", "ERROR", "MEMORY", "TIME STAMP"
        ];

        function createTextTexture(text, fontStyle) {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          ctx.font = fontStyle;
          const textWidth = ctx.measureText(text).width;
          
          canvas.width = Math.max(textWidth + 20, 100);
          canvas.height = 60;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = fontStyle;
          ctx.fillStyle = "rgba(255, 255, 255, 1)";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          
          ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
          ctx.shadowBlur = 10;
          
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.needsUpdate = true;
          
          return { texture, ratio: canvas.width / canvas.height };
        }

        function init() {
          // Scene setup
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x000000);
          scene.fog = new THREE.FogExp2(0x000000, 0.025);
          
          camera = new THREE.PerspectiveCamera(
            70,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.z = 0;

          renderer = new THREE.WebGLRenderer({
            antialias: false,
            alpha: false
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(dpr);
          container.appendChild(renderer.domElement);

          // Populate sprites (reduced count for performance on mobile)
          const isMobile = window.innerWidth < 768;
          const count = isMobile ? 150 : 300;
          
          for (let i = 0; i < count; i++) {
            let txt, fontSize;
            const r = Math.random();
            
            if (r > 0.92) {
              txt = nietzscheQuote[Math.floor(Math.random() * nietzscheQuote.length)];
              fontSize = 'Bold 60px "Cinzel", serif';
            } else if (r > 0.7) {
              txt = ancientWords[Math.floor(Math.random() * ancientWords.length)];
              fontSize = 'Bold 45px "Cormorant Garamond", serif';
            } else {
              txt = symbols[Math.floor(Math.random() * symbols.length)];
              fontSize = '40px "EB Garamond", serif';
            }

            const { texture, ratio } = createTextTexture(txt, fontSize);
            
            const material = new THREE.SpriteMaterial({
              map: texture,
              color: 0xffffff,
              transparent: true,
              opacity: Math.random() * 0.5 + 0.2,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });

            const sprite = new THREE.Sprite(material);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 15;
            
            sprite.position.x = Math.cos(angle) * radius;
            sprite.position.y = Math.sin(angle) * radius;
            sprite.position.z = -Math.random() * 100;

            const scale = Math.random() * 2 + 0.5;
            sprite.scale.set(scale * ratio, scale, 1);

            sprite.userData = {
              speed: Math.random() * 0.1 + 0.05,
              wobbleSpeed: Math.random() * 2,
              wobbleAmp: Math.random() * 0.1,
              initialX: sprite.position.x,
              initialY: sprite.position.y
            };

            scene.add(sprite);
            sprites.push(sprite);
          }

          // Particle dust (reduced for mobile)
          const particlesGeo = new THREE.BufferGeometry();
          const pCount = isMobile ? 300 : 600;
          const pPos = new Float32Array(pCount * 3);
          for (let i = 0; i < pCount * 3; i++) {
            pPos[i] = (Math.random() - 0.5) * 60;
          }
          particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
          const particlesMat = new THREE.PointsMaterial({
            size: 0.05,
            color: 0x888888,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
          });
          particleSystem = new THREE.Points(particlesGeo, particlesMat);
          scene.add(particleSystem);

          // Mouse tracking
          document.addEventListener('mousemove', handleMouseMove);
        }

        function handleMouseMove(e) {
          mouseX = (e.clientX - window.innerWidth / 2) * 0.0005;
          mouseY = (e.clientY - window.innerHeight / 2) * 0.0005;
        }

        function handleResize() {
          if (!camera || !renderer) return;
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
          if (!isActive) {
            animationId = null;
            return;
          }

          time += 0.01;

          // Move Sprites
          sprites.forEach(sprite => {
            sprite.position.z += sprite.userData.speed;
            
            sprite.position.x = sprite.userData.initialX +
              Math.cos(time * sprite.userData.wobbleSpeed) * sprite.userData.wobbleAmp;
            sprite.position.y = sprite.userData.initialY +
              Math.sin(time * sprite.userData.wobbleSpeed) * sprite.userData.wobbleAmp;

            const dist = sprite.position.z;
            if (dist < -50) {
              sprite.material.opacity = 0;
            } else if (dist < -10) {
              sprite.material.opacity = Math.min(1, (dist + 50) / 40) * 0.6;
            } else if (dist > 2) {
              sprite.material.opacity -= 0.05;
            }

            if (sprite.position.z > 5 || sprite.material.opacity <= 0) {
              if (sprite.position.z > 5) {
                sprite.position.z = -100 - Math.random() * 20;
                sprite.material.opacity = 0;
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 15;
                sprite.userData.initialX = Math.cos(angle) * radius;
                sprite.userData.initialY = Math.sin(angle) * radius;
                sprite.position.x = sprite.userData.initialX;
                sprite.position.y = sprite.userData.initialY;
              }
            }
          });

          // Move Particles
          if (particleSystem) {
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 2; i < positions.length; i += 3) {
              positions[i] += 0.2;
              if (positions[i] > 5) positions[i] = -60;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
          }

          // Camera parallax
          camera.rotation.x += (mouseY - camera.rotation.x) * 0.05;
          camera.rotation.y += (mouseX - camera.rotation.y) * 0.05;

          renderer.render(scene, camera);
          animationId = requestAnimationFrame(animate);
        }

        function start() {
          if (isActive) return;
          isActive = true;
          
          if (!renderer) {
            init();
          }
          
          window.addEventListener('resize', handleResize);
          animate();
          console.log('[LAYER2] Text tunnel started');
        }

        function stop() {
          isActive = false;
          window.removeEventListener('resize', handleResize);
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          console.log('[LAYER2] Text tunnel stopped');
        }

        function cleanup() {
          stop();
          document.removeEventListener('mousemove', handleMouseMove);
          
          if (renderer) {
            renderer.dispose();
            if (container.contains(renderer.domElement)) {
              container.removeChild(renderer.domElement);
            }
          }
          
          sprites.forEach(sprite => {
            if (sprite.material.map) sprite.material.map.dispose();
            sprite.material.dispose();
          });
          sprites = [];
          
          if (particleSystem) {
            particleSystem.geometry.dispose();
            particleSystem.material.dispose();
          }
          
          scene = null;
          camera = null;
          renderer = null;
        }

        // Watch for layer changes
        function checkLayer() {
          const isLayer2 = document.body.classList.contains('layer-2');
          if (isLayer2 && !isActive) {
            start();
          } else if (!isLayer2 && isActive) {
            stop();
          }
        }

        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'class') {
              checkLayer();
            }
          });
        });
        
        observer.observe(document.body, { attributes: true });
        
        // Initial check
        checkLayer();
        
        console.log('[LAYER2] Text tunnel system initialized');
      }).catch(err => {
        console.warn('[LAYER2] Three.js failed to load:', err);
      });
    </script>

    <!-- ============ LAYER 3 CRYSTALLINE SPHERE SYSTEM ============ -->
    <script>
      /**
       * Layer 3 Visual - Crystalline Sphere with Shards
       * Only runs when Layer 3 is active, pauses otherwise
       */
      (function() {
        const canvas = document.getElementById('layer3-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let mouse = { x: -1000, y: -1000, active: false };
        let animationId = null;
        let isActive = false;
        let sphere = null;
        let stars = [];
        
        // Cap DPR for performance
        const dpr = Math.min(window.devicePixelRatio || 1, 1.5);

        function resize() {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          
          // Reinitialize sphere position on resize
          if (sphere) {
            sphere.x = width / 2;
            sphere.y = height / 2;
          }
        }

        function handleMouseMove(e) {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          mouse.active = true;
        }

        // Star class for background
        function Star() {
          this.reset();
        }
        Star.prototype.reset = function() {
          this.x = Math.random() * width;
          this.y = Math.random() * height;
          this.size = Math.random() * 2;
          this.speed = Math.random() * 0.15 + 0.05;
          this.opacity = Math.random();
        };
        Star.prototype.update = function() {
          this.y -= this.speed;
          if (this.y < 0) {
            this.y = height;
            this.x = Math.random() * width;
          }
        };
        Star.prototype.draw = function() {
          ctx.fillStyle = 'rgba(255, 255, 255, ' + this.opacity + ')';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        };

        // Shard class for falling fragments
        function Shard(x, y, vx, vy, color) {
          this.x = x;
          this.y = y;
          this.vx = vx || (Math.random() - 0.5) * 4;
          this.vy = vy || (Math.random() * 5 + 2);
          this.size = Math.random() * 6 + 3;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotSpeed = (Math.random() - 0.5) * 0.2;
          this.life = 1.0;
          this.decay = Math.random() * 0.02 + 0.005;
          this.color = color || (Math.random() > 0.4 ? '#22d3ee' : '#ffffff');
          this.history = [];
        }
        Shard.prototype.update = function() {
          this.history.unshift({x: this.x, y: this.y});
          if (this.history.length > 5) this.history.pop();
          
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.05;
          this.rotation += this.rotSpeed;
          this.life -= this.decay;
        };
        Shard.prototype.draw = function() {
          if (this.life <= 0) return;
          
          // Draw trail
          ctx.beginPath();
          ctx.strokeStyle = this.color;
          ctx.globalAlpha = this.life * 0.3;
          ctx.lineWidth = 1;
          for (var i = 0; i < this.history.length; i++) {
            var p = this.history[i];
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.globalAlpha = this.life;
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(-this.size, 0);
          ctx.lineTo(0, -this.size * 1.5);
          ctx.lineTo(this.size, 0);
          ctx.lineTo(0, this.size * 0.5);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
          ctx.globalAlpha = 1;
        };

        // Crystal Sphere class
        function CrystalSphere() {
          this.x = width / 2;
          this.y = height / 2;
          this.radius = Math.min(width, height) * 0.1;
          this.radius = Math.max(60, Math.min(this.radius, 100));
          this.history = [];
          this.shards = [];
          this.rotation = 0;
          this.rotSpeed = 0.02;
          this.lerpSpeed = 0.15;
          
          // Pre-generate facets
          this.facets = [];
          var count = 12;
          for (var i = 0; i < count; i++) {
            var angle = (i / count) * Math.PI * 2;
            var innerRadius = this.radius * (0.4 + Math.random() * 0.6);
            this.facets.push({
              angle: angle,
              innerRadius: innerRadius,
              color: Math.random() > 0.5 ? '#ffffff' : '#22d3ee'
            });
          }
        }

        CrystalSphere.prototype.update = function() {
          var targetX = mouse.active ? mouse.x : (width/2 + Math.cos(Date.now() * 0.001) * 150);
          var targetY = mouse.active ? mouse.y : (height/2 + Math.sin(Date.now() * 0.001) * 100);
          
          this.history.unshift({x: this.x, y: this.y, rotation: this.rotation});
          if (this.history.length > 10) this.history.pop();

          var dx = targetX - this.x;
          var dy = targetY - this.y;
          this.x += dx * this.lerpSpeed;
          this.y += dy * this.lerpSpeed;
          this.rotation += this.rotSpeed + (Math.hypot(dx, dy) * 0.0005);

          // Falling fragments (reduced rate for performance)
          if (Math.random() < 0.15) {
            var angle = Math.random() * Math.PI * 2;
            var px = this.x + Math.cos(angle) * this.radius * 0.5;
            var py = this.y + Math.sin(angle) * this.radius * 0.5;
            this.shards.push(new Shard(px, py));
          }

          // Fast movement burst
          if (Math.hypot(dx, dy) > 20 && Math.random() < 0.3) {
            this.shards.push(new Shard(
              this.x, 
              this.y, 
              (Math.random()-0.5) * 10, 
              (Math.random()-0.5) * 10
            ));
          }

          // Update and clean up shards (limit count for performance)
          var maxShards = window.innerWidth < 768 ? 30 : 60;
          for (var i = this.shards.length - 1; i >= 0; i--) {
            this.shards[i].update();
            if (this.shards[i].life <= 0) {
              this.shards.splice(i, 1);
            }
          }
          while (this.shards.length > maxShards) {
            this.shards.shift();
          }
        };

        CrystalSphere.prototype.drawSphere = function(x, y, rot, alpha, chromaticShift) {
          chromaticShift = chromaticShift || 0;
          var self = this;
          
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rot);
          ctx.globalAlpha = alpha;
          
          ctx.shadowBlur = 40 * alpha;
          ctx.shadowColor = 'rgba(34, 211, 238, 0.8)';

          // Base Glow
          ctx.beginPath();
          ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(34, 211, 238, ' + (0.1 * alpha) + ')';
          ctx.fill();

          // Draw Facets
          for (var i = 0; i < this.facets.length; i++) {
            var f = this.facets[i];
            var nextF = this.facets[(i + 1) % this.facets.length];
            
            // Chromatic aberration for afterimages
            if (chromaticShift > 0) {
              ctx.strokeStyle = '#ff0055';
              this.renderFacet(f, nextF, chromaticShift);
              ctx.strokeStyle = '#00ffaa';
              this.renderFacet(f, nextF, -chromaticShift);
            }

            ctx.strokeStyle = f.color;
            ctx.lineWidth = 1;
            this.renderFacet(f, nextF, 0);
          }

          // Central core cross
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-10, 0); ctx.lineTo(10, 0);
          ctx.moveTo(0, -10); ctx.lineTo(0, 10);
          ctx.stroke();

          ctx.restore();
        };

        CrystalSphere.prototype.renderFacet = function(f, nextF, shift) {
          ctx.beginPath();
          var x1 = Math.cos(f.angle) * this.radius + shift;
          var y1 = Math.sin(f.angle) * this.radius;
          var x2 = Math.cos(nextF.angle) * this.radius + shift;
          var y2 = Math.sin(nextF.angle) * this.radius;
          
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(0, 0);
          ctx.closePath();
          ctx.stroke();
        };

        CrystalSphere.prototype.draw = function() {
          // Draw shards
          for (var i = 0; i < this.shards.length; i++) {
            this.shards[i].draw();
          }

          // Draw afterimages
          for (var j = 0; j < this.history.length; j++) {
            var pos = this.history[j];
            var opacity = (1 - (j / this.history.length)) * 0.3;
            this.drawSphere(pos.x, pos.y, pos.rotation, opacity, j * 2);
          }

          // Draw current core
          this.drawSphere(this.x, this.y, this.rotation, 1.0, 0);
        };

        function init() {
          resize();
          
          // Create stars (reduced count on mobile)
          var starCount = window.innerWidth < 768 ? 80 : 150;
          stars = [];
          for (var i = 0; i < starCount; i++) {
            stars.push(new Star());
          }
          
          sphere = new CrystalSphere();
        }

        function animate() {
          if (!isActive) {
            animationId = null;
            return;
          }
          
          // Semi-transparent clear for trail effect (matches reference: rgba(2, 6, 23, 0.15))
          ctx.fillStyle = 'rgba(2, 6, 23, 0.15)';
          ctx.fillRect(0, 0, width, height);
          
          // Cosmic depth gradient (matches reference)
          var grad = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width);
          grad.addColorStop(0, 'rgba(15, 23, 42, 0.2)');
          grad.addColorStop(1, 'transparent');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, width, height);

          // Update and draw stars
          for (var i = 0; i < stars.length; i++) {
            stars[i].update();
            stars[i].draw();
          }

          // Update and draw sphere
          sphere.update();
          sphere.draw();

          animationId = requestAnimationFrame(animate);
        }

        function start() {
          if (isActive) return;
          isActive = true;
          window.addEventListener('resize', resize);
          window.addEventListener('mousemove', handleMouseMove);
          init();
          animate();
          console.log('[LAYER3] Crystalline sphere started');
        }

        function stop() {
          isActive = false;
          window.removeEventListener('resize', resize);
          window.removeEventListener('mousemove', handleMouseMove);
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          console.log('[LAYER3] Crystalline sphere stopped');
        }

        // Watch for layer changes
        function checkLayer() {
          var isLayer3 = document.body.classList.contains('layer-3');
          if (isLayer3 && !isActive) {
            start();
          } else if (!isLayer3 && isActive) {
            stop();
          }
        }

        // Use MutationObserver to watch body class changes
        var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'class') {
              checkLayer();
            }
          });
        });
        
        observer.observe(document.body, { attributes: true });
        
        // Initial check
        checkLayer();
        
        console.log('[LAYER3] Crystalline sphere system initialized');
      })();
    </script>

    <!-- ============ LAYER 4 WATER RIPPLE & CONSTELLATION SYSTEM ============ -->
    <script>
      /**
       * Layer 4 Visual - Water Ripples with Constellation Connections
       * Only runs when Layer 4 is active, pauses otherwise
       */
      (function() {
        const canvas = document.getElementById('l4-pond-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let ripples = [];
        let mouse = { x: -1000, y: -1000 };
        let animationId = null;
        let isActive = false;
        
        const maxRipples = 12;
        const connectionDistance = 300;
        
        // Cap DPR for performance
        const dpr = Math.min(window.devicePixelRatio || 1, 1.5);

        // Ripple class
        function Ripple(x, y, isClick) {
          this.x = x;
          this.y = y;
          this.age = 0;
          this.maxAge = isClick ? 200 : 120;
          this.radius = 0;
          this.strength = isClick ? 2.5 : 1.0;
          this.opacity = 1.0;
          this.rings = isClick ? 3 : 2;
        }

        Ripple.prototype.update = function() {
          this.age++;
          this.opacity = 1 - (this.age / this.maxAge);
          this.radius += 1.2;
        };

        Ripple.prototype.draw = function() {
          for (var i = 0; i < this.rings; i++) {
            var r = this.radius - (i * 20);
            if (r > 0) {
              ctx.beginPath();
              ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(165, 243, 252, ' + (this.opacity * (0.2 / (i + 1))) + ')';
              ctx.lineWidth = 1.5;
              ctx.stroke();
            }
          }
          
          // Draw center point (star) - larger and brighter
          ctx.beginPath();
          ctx.arc(this.x, this.y, 4 * this.opacity, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, ' + (this.opacity * 0.8) + ')';
          ctx.fill();
          
          // Add glow around center point
          ctx.beginPath();
          ctx.arc(this.x, this.y, 8 * this.opacity, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(165, 243, 252, ' + (this.opacity * 0.2) + ')';
          ctx.fill();
        };

        function resize() {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function handleMouseMove(e) {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          
          // Create subtle ripples on movement (reduced frequency)
          if (isActive && Math.random() > 0.94) {
            ripples.push(new Ripple(mouse.x, mouse.y, false));
            // Limit ripple count
            while (ripples.length > maxRipples) {
              ripples.shift();
            }
          }
        }

        function handleMouseDown(e) {
          if (!isActive) return;
          ripples.push(new Ripple(e.clientX, e.clientY, true));
          while (ripples.length > maxRipples) {
            ripples.shift();
          }
        }

        function drawConstellations() {
          for (var i = 0; i < ripples.length; i++) {
            for (var j = i + 1; j < ripples.length; j++) {
              var dx = ripples[i].x - ripples[j].x;
              var dy = ripples[i].y - ripples[j].y;
              var dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < connectionDistance) {
                var alpha = (1 - dist / connectionDistance) * 0.35 * Math.min(ripples[i].opacity, ripples[j].opacity);
                ctx.beginPath();
                ctx.moveTo(ripples[i].x, ripples[i].y);
                ctx.lineTo(ripples[j].x, ripples[j].y);
                ctx.strokeStyle = 'rgba(165, 243, 252, ' + alpha + ')';
                ctx.lineWidth = 1.5;
                ctx.stroke();
              }
            }
          }
        }

        function animate() {
          if (!isActive) {
            animationId = null;
            return;
          }

          // Semi-transparent clear for trail effect (pond stillness)
          ctx.fillStyle = 'rgba(2, 6, 23, 0.15)';
          ctx.fillRect(0, 0, width, height);

          // Update and draw ripples
          ripples = ripples.filter(function(r) { return r.age < r.maxAge; });
          ripples.forEach(function(r) {
            r.update();
            r.draw();
          });

          // Draw constellation connections
          drawConstellations();

          // Mouse position glow
          var grad = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 150);
          grad.addColorStop(0, 'rgba(165, 243, 252, 0.05)');
          grad.addColorStop(1, 'rgba(165, 243, 252, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, width, height);

          animationId = requestAnimationFrame(animate);
        }

        function start() {
          if (isActive) return;
          isActive = true;
          resize();
          window.addEventListener('resize', resize);
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('mousedown', handleMouseDown);
          animate();
          console.log('[LAYER4] Water ripple started');
        }

        function stop() {
          isActive = false;
          window.removeEventListener('resize', resize);
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mousedown', handleMouseDown);
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          ripples = [];
          console.log('[LAYER4] Water ripple stopped');
        }

        // Watch for layer changes
        function checkLayer() {
          var isLayer4 = document.body.classList.contains('layer-4');
          if (isLayer4 && !isActive) {
            start();
          } else if (!isLayer4 && isActive) {
            stop();
          }
        }

        var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'class') {
              checkLayer();
            }
          });
        });
        
        observer.observe(document.body, { attributes: true });
        
        // Initial check
        checkLayer();
        
        console.log('[LAYER4] Water ripple system initialized');
      })();
    </script>

    <!-- ============ LAYER 5 ORPHEUS 3D TUBES SYSTEM ============ -->
    <script type="module">
      /**
       * Layer 5 Visual - 3D Tubes (Cosmic Frequency)
       * Only runs when Layer 5 is active, pauses otherwise
       */
      (function() {
        const canvas = document.getElementById('l5-tube-canvas');
        if (!canvas) return;

        let tubeApp = null;
        let isActive = false;
        let isInitialized = false;

        async function initTubes() {
          if (isInitialized) return;

          try {
            const module = await import('https://cdn.jsdelivr.net/npm/threejs-components@0.0.19/build/cursors/tubes1.min.js');
            const TubesCursor = module.default;

            tubeApp = TubesCursor(canvas, {
              tubes: {
                colors: ["#22d3ee", "#818cf8", "#ffffff"],
                lights: {
                  intensity: 400,
                  colors: ["#06b6d4", "#ffffff", "#4f46e5", "#000000"]
                }
              }
            });

            isInitialized = true;
            console.log('[LAYER5] 3D Tubes initialized');

            // Click randomize colors (only when layer 5 is active and not clicking gate links)
            window.addEventListener('mousedown', (e) => {
              if (!isActive) return;
              if (e.target.closest('.gate-link') || e.target.closest('[data-gate]')) return;

              const randomHex = () => "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
              const newTubes = [randomHex(), randomHex(), "#ffffff"];
              const newLights = [randomHex(), randomHex(), randomHex(), "#000000"];
              tubeApp.tubes.setColors(newTubes);
              tubeApp.tubes.setLightsColors(newLights);
            });

          } catch (err) {
            console.error('[LAYER5] 3D Tubes failed to initialize:', err);
          }
        }

        function start() {
          if (isActive) return;
          isActive = true;
          canvas.style.opacity = '1';
          canvas.style.pointerEvents = 'auto';
          
          if (!isInitialized) {
            initTubes();
          }
          
          console.log('[LAYER5] Tubes started');
        }

        function stop() {
          isActive = false;
          canvas.style.opacity = '0';
          canvas.style.pointerEvents = 'none';
          console.log('[LAYER5] Tubes stopped');
        }

        // Watch for layer changes
        function checkLayer() {
          const isLayer5 = document.body.classList.contains('layer-5');
          if (isLayer5 && !isActive) {
            start();
          } else if (!isLayer5 && isActive) {
            stop();
          }
        }

        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.attributeName === 'class') {
              checkLayer();
            }
          });
        });

        observer.observe(document.body, { attributes: true });

        // Initial check
        checkLayer();

        console.log('[LAYER5] Orpheus system initialized');
      })();
    </script>
  <!-- Home Index ÁõÆÂΩïÂÖ•Âè£ÔºàÁã¨Á´ãÂÆπÂô®Ôºâ -->
  <div id="home-index" class="home-index">
    <button class="home-index-toggle" aria-label="Open Index">Index</button>
    <nav class="home-index-menu" hidden>
      <a href="/writings">Writings</a>
      <a href="/fragments">Fragments</a>
      <a href="/message">Message</a>
      <a href="/music">Music</a>
    </nav>
  </div>

  <style>
  /* Home Index ÁõÆÂΩïÊ†∑Âºè */
  .home-index {
    position: fixed;
    right: 2vw;
    bottom: 2vw;
    z-index: 50;
    font-size: 18px;
    pointer-events: auto;
    user-select: none;
  }
  .home-index-toggle {
    background: rgba(30,30,30,0.7);
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 4px 12px;
    font-size: 13px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  .home-index-toggle:hover,
  .home-index-toggle:focus {
    opacity: 1;
  }
  .home-index-menu {
    display: flex;
    flex-direction: column;
    position: absolute;
    right: 0;
    bottom: 36px;
    background: rgba(20,20,20,0.95);
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    padding: 8px 0;
    min-width: 120px;
    opacity: 0.98;
  }
  .home-index-menu a {
    color: #eee;
    text-decoration: none;
    padding: 6px 18px;
    font-size: 14px;
    transition: background 0.15s;
  }
  .home-index-menu a:hover {
    background: rgba(60,60,60,0.18);
  }
  </style>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    const toggle = document.querySelector('.home-index-toggle');
    const menu = document.querySelector('.home-index-menu');
    let open = false;

    // Â±ïÂºÄ/Êî∂Ëµ∑ÁõÆÂΩï
    toggle.addEventListener('click', function (e) {
      e.stopPropagation();
      open = !open;
      menu.hidden = !open;
    });

    // ÁÇπÂáªÁõÆÂΩïÈìæÊé•Áõ¥Êé•Ë∑≥ËΩ¨
    menu.addEventListener('click', function (e) {
      if (e.target.tagName === 'A') {
        window.location.href = e.target.href;
        e.preventDefault();
      }
    });

    // ÁÇπÂáªÈ°µÈù¢ÂÖ∂‰ªñÂå∫ÂüüÊî∂Ëµ∑ÁõÆÂΩï
    document.addEventListener('click', function (e) {
      if (open && !toggle.contains(e.target) && !menu.contains(e.target)) {
        menu.hidden = true;
        open = false;
      }
    });

    // ÂèØÈÄâÔºöESC ÈîÆÊî∂Ëµ∑
    document.addEventListener('keydown', function (e) {
      if (open && e.key === 'Escape') {
        menu.hidden = true;
        open = false;
      }
    });
  });
  </script>
  </body>
</html>