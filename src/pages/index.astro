---
import '../styles/global.css';
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>âˆž</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">
  </head>
  <body class="bg-black overflow-hidden select-none m-0 p-0">
    <!-- Background elements -->
    <div id="noise" class="fixed inset-0 opacity-5 mix-blend-overlay pointer-events-none"></div>
    <canvas id="stars" class="fixed inset-0 w-full h-full pointer-events-none"></canvas>
    
    <!-- AION Canvas for Layer 1 -->
    <canvas id="aion-canvas" class="fixed inset-0 w-full h-full pointer-events-none" style="z-index: 2;"></canvas>
    
    <!-- Bloom orbs -->
    <div class="bloom-orb bloom-1"></div>
    <div class="bloom-orb bloom-2"></div>
    <div class="bloom-orb bloom-3"></div>
    
    <!-- FX overlays -->
    <div id="warp-glow" class="warp-glow"></div>
    <div id="rift-slit" class="rift-slit"></div>
    <div id="vignette" class="vignette"></div>

    <!-- Layer container -->
    <div id="drift-container" class="fixed inset-0">
      <div id="portal" class="relative w-full h-full">
        <!-- Layer 1: Landing/Home - AION Infinity -->
        <div class="layer active" data-layer="1" data-route="/">
          <div class="layer-content">
            <div class="layer-bg layer-bg-void"></div>
            <!-- AION visual is rendered on the canvas above -->
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <!-- Empty - the AION infinity + particles are drawn on canvas -->
            </div>
          </div>
        </div>

        <!-- Layer 2: Writings -->
        <div class="layer" data-layer="2" data-route="/writings">
          <div class="layer-content">
            <div class="layer-bg layer-bg-monolith"></div>
            <div class="monolith-shapes"></div>
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <a href="/writings" class="gate-link" data-gate>
                <span class="gate-text text-6xl md:text-8xl">Writings</span>
              </a>
            </div>
          </div>
        </div>

        <!-- Layer 3: Fragments -->
        <div class="layer" data-layer="3" data-route="/fragments">
          <div class="layer-content">
            <div class="layer-bg layer-bg-debris"></div>
            <div class="debris-particles"></div>
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <a href="/fragments" class="gate-link" data-gate>
                <span class="gate-text text-6xl md:text-8xl">Fragments</span>
              </a>
            </div>
          </div>
        </div>

        <!-- Layer 4: Message -->
        <div class="layer" data-layer="4" data-route="/message">
          <div class="layer-content">
            <div class="layer-bg layer-bg-beacon"></div>
            <div class="beacon-rays"></div>
            <div class="layer-inner flex flex-col items-center justify-center min-h-screen px-8 text-center">
              <a href="/message" class="gate-link" data-gate>
                <span class="gate-text text-6xl md:text-8xl">Message</span>
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>

    <style>
      :root {
        --warm-white: #F5F2EA;
        --warm-white-dim: rgba(245, 242, 234, 0.5);
        --warm-white-glow: rgba(245, 242, 234, 0.15);
      }

      /* Noise texture */
      #noise {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      }

      /* Bloom orbs */
      .bloom-orb {
        position: absolute;
        border-radius: 50%;
        filter: blur(100px);
        opacity: 0;
        transition: opacity 1.5s ease, transform 3s ease;
      }
      .bloom-1 {
        width: 500px; height: 500px;
        background: radial-gradient(circle, rgba(245,242,234,0.08) 0%, transparent 70%);
        top: 20%; left: 10%;
      }
      .bloom-2 {
        width: 400px; height: 400px;
        background: radial-gradient(circle, rgba(245,242,234,0.06) 0%, transparent 70%);
        bottom: 20%; right: 15%;
      }
      .bloom-3 {
        width: 450px; height: 450px;
        background: radial-gradient(circle, rgba(245,242,234,0.07) 0%, transparent 70%);
        top: 50%; left: 50%; transform: translate(-50%, -50%);
      }
      body.layer-2 .bloom-1 { opacity: 1; }
      body.layer-3 .bloom-2 { opacity: 1; }
      body.layer-4 .bloom-3 { opacity: 1; }
      body.transitioning .bloom-orb { opacity: 0.3; transform: scale(1.5); }

      /* AION canvas visibility */
      #aion-canvas {
        opacity: 1;
        transition: opacity 0.8s ease;
      }
      body:not(.layer-1) #aion-canvas {
        opacity: 0;
        pointer-events: none;
      }

      /* Gate typography */
      .gate-text {
        font-family: 'Cormorant Garamond', Georgia, serif;
        font-weight: 300;
        font-style: italic;
        color: var(--warm-white);
        text-shadow: 0 0 60px var(--warm-white-glow), 0 0 120px var(--warm-white-glow);
        letter-spacing: 0.05em;
        transition: all 0.6s ease;
      }

      .gate-link {
        display: inline-block;
        cursor: pointer;
        transition: transform 0.6s ease;
      }
      .gate-link:hover {
        transform: scale(1.02);
      }
      .gate-link:hover .gate-text {
        text-shadow: 0 0 80px rgba(245,242,234,0.25), 0 0 160px var(--warm-white-glow);
      }

      /* Layer backgrounds */
      .layer-bg {
        position: absolute;
        inset: 0;
      }
      .layer-bg-void {
        background: radial-gradient(ellipse at center, #080808 0%, #000000 100%);
      }
      .layer-bg-monolith {
        background:
          radial-gradient(ellipse at 30% 70%, rgba(245,242,234,0.03) 0%, transparent 50%),
          radial-gradient(ellipse at center, #060606 0%, #000000 100%);
      }
      .layer-bg-debris {
        background:
          radial-gradient(ellipse at 70% 30%, rgba(245,242,234,0.025) 0%, transparent 50%),
          radial-gradient(ellipse at 30% 80%, rgba(245,242,234,0.02) 0%, transparent 40%),
          radial-gradient(ellipse at center, #050505 0%, #000000 100%);
      }
      .layer-bg-beacon {
        background:
          radial-gradient(ellipse at center, rgba(245,242,234,0.04) 0%, transparent 40%),
          radial-gradient(ellipse at center, #070705 0%, #000000 100%);
      }

      /* Subtle decorative elements */
      .monolith-shapes {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, transparent 48%, rgba(245,242,234,0.01) 50%, transparent 52%);
        pointer-events: none;
      }
      .debris-particles {
        position: absolute;
        inset: 0;
        background-image:
          radial-gradient(1px 1px at 20% 30%, rgba(245,242,234,0.15), transparent),
          radial-gradient(1px 1px at 80% 20%, rgba(245,242,234,0.1), transparent),
          radial-gradient(1px 1px at 40% 70%, rgba(245,242,234,0.12), transparent),
          radial-gradient(1px 1px at 60% 50%, rgba(245,242,234,0.08), transparent);
        pointer-events: none;
        animation: debris-drift 30s linear infinite;
      }
      @keyframes debris-drift {
        0% { transform: translate(0, 0); }
        100% { transform: translate(-30px, 30px); }
      }
      .beacon-rays {
        position: absolute;
        inset: 0;
        background: conic-gradient(from 0deg at 50% 50%,
          transparent 0deg, rgba(245,242,234,0.015) 10deg, transparent 20deg,
          transparent 90deg, rgba(245,242,234,0.015) 100deg, transparent 110deg,
          transparent 180deg, rgba(245,242,234,0.015) 190deg, transparent 200deg,
          transparent 270deg, rgba(245,242,234,0.015) 280deg, transparent 290deg);
        pointer-events: none;
        animation: beacon-rotate 40s linear infinite;
      }
      @keyframes beacon-rotate {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Layer base */
      .layer {
        position: absolute;
        inset: 0;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s ease;
      }
      .layer.active {
        opacity: 1;
        pointer-events: auto;
      }
      .layer-content {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        will-change: transform, filter;
      }
      .layer-inner {
        position: relative;
        z-index: 1;
        will-change: transform;
      }

      /* Idle float */
      .layer.active:not(.transitioning) .layer-inner {
        animation: idle-float 10s ease-in-out infinite;
      }
      @keyframes idle-float {
        0%, 100% { transform: translateY(0) scale(1); }
        50% { transform: translateY(-8px) scale(1.002); }
      }

      /* Warp transition - slower, smoother */
      .layer-content.warp-out {
        animation: warp-out 1100ms cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      .layer-content.warp-in {
        animation: warp-in 1100ms cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      @keyframes warp-out {
        0% {
          transform: scale(1) translateZ(0);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
        35% {
          transform: scale(1.4) translateZ(100px);
          filter: blur(3px) brightness(1.2);
          opacity: 0.85;
        }
        70% {
          transform: scale(2.5) translateZ(300px);
          filter: blur(10px) brightness(1.6);
          opacity: 0.4;
        }
        100% {
          transform: scale(4) translateZ(500px);
          filter: blur(16px) brightness(2);
          opacity: 0;
        }
      }
      @keyframes warp-in {
        0% {
          transform: scale(0.15) translateZ(-500px);
          filter: blur(16px) brightness(0.2);
          opacity: 0;
        }
        30% {
          transform: scale(0.5) translateZ(-200px);
          filter: blur(8px) brightness(0.5);
          opacity: 0.4;
        }
        65% {
          transform: scale(0.85) translateZ(-50px);
          filter: blur(2px) brightness(0.9);
          opacity: 0.85;
        }
        100% {
          transform: scale(1) translateZ(0);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
      }

      /* Rift fall transition - slower, more dramatic */
      .layer-content.rift-out {
        animation: rift-out 900ms cubic-bezier(0.55, 0.05, 0.67, 0.19) forwards;
      }
      .layer-content.rift-in {
        animation: rift-in 1100ms cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
      }
      @keyframes rift-out {
        0% {
          transform: translateY(0) rotate(0deg) scale(1);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
        25% {
          transform: translateY(30px) rotate(1deg) scale(0.98);
          filter: blur(1px) brightness(0.8);
          opacity: 0.9;
        }
        60% {
          transform: translateY(150px) rotate(3deg) scale(0.85);
          filter: blur(6px) brightness(0.4);
          opacity: 0.5;
        }
        100% {
          transform: translateY(400px) rotate(6deg) scale(0.6);
          filter: blur(14px) brightness(0.1);
          opacity: 0;
        }
      }
      @keyframes rift-in {
        0% {
          transform: translateY(-400px) rotate(-4deg) scale(0.6);
          filter: blur(14px) brightness(0.1);
          opacity: 0;
        }
        40% {
          transform: translateY(-50px) rotate(-1deg) scale(0.95);
          filter: blur(4px) brightness(0.7);
          opacity: 0.7;
        }
        70% {
          transform: translateY(15px) rotate(0.5deg) scale(1.01);
          filter: blur(1px) brightness(0.95);
          opacity: 0.95;
        }
        85% {
          transform: translateY(-5px) rotate(-0.2deg) scale(1.005);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
        100% {
          transform: translateY(0) rotate(0deg) scale(1);
          filter: blur(0) brightness(1);
          opacity: 1;
        }
      }

      /* FX overlays */
      .warp-glow {
        position: absolute;
        top: 50%; left: 50%;
        width: 0; height: 0;
        background: radial-gradient(circle, rgba(245,242,234,0.6) 0%, rgba(245,242,234,0) 70%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
      }
      .warp-glow.active {
        width: 400px; height: 400px;
        opacity: 0.3;
      }

      .rift-slit {
        position: absolute;
        top: 0; left: 50%;
        width: 3px; height: 100%;
        background: linear-gradient(180deg, transparent 0%, rgba(245,242,234,0.7) 30%, rgba(245,242,234,0.7) 70%, transparent 100%);
        transform: translateX(-50%) scaleY(0);
        opacity: 0;
        filter: blur(2px);
        box-shadow: 0 0 40px 15px rgba(245,242,234,0.2);
      }
      .rift-slit.active {
        animation: rift-slit-flash 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      @keyframes rift-slit-flash {
        0% { transform: translateX(-50%) scaleY(0); opacity: 0; }
        25% { transform: translateX(-50%) scaleY(1); opacity: 1; }
        100% { transform: translateX(-50%) scaleY(0); opacity: 0; }
      }

      .vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.7) 100%);
        opacity: 0;
        transition: opacity 0.6s ease;
      }
      .vignette.active {
        opacity: 1;
      }

      /* Drift container */
      #drift-container {
        transition: transform 0.15s ease-out;
      }

      /* Text shadow fix for warm-white class */
      .text-warm-white {
        color: var(--warm-white);
        text-shadow: 0 0 40px var(--warm-white-glow), 0 0 80px var(--warm-white-glow);
      }
    </style>

    <script>
      // ============ STATE ============
      let currentLayer = 1;
      let isTransitioning = false;
      const totalLayers = 4;

      // Drift state
      const drift = { x: 0, y: 0, vx: 0, vy: 0 };
      const keys = { up: false, down: false, left: false, right: false };
      const driftSpeed = 0.6;
      const driftFriction = 0.94;
      const driftMax = 50;
      const mouseParallax = { x: 0, y: 0 };

      // Star state
      let stars = [];
      let starSpeed = 0.2;
      let targetStarSpeed = 0.2;
      const baseStarSpeed = 0.2;
      const warpStarSpeed = 12;
      const fallStarSpeed = 6;

      // Mobile state
      let longPressTimer = null;
      let touchStartTime = 0;
      const longPressDuration = 600;

      // Double click
      let lastClickTime = 0;
      const doubleClickThreshold = 300;

      // Timing constants (slower)
      const warpDuration = 2200;
      const warpMidpoint = 1100;
      const fallDuration = 2000;
      const fallMidpoint = 900;

      // ============ ELEMENTS ============
      const canvas = document.getElementById('stars');
      const ctx = canvas.getContext('2d');
      const driftContainer = document.getElementById('drift-container');
      const warpGlow = document.getElementById('warp-glow');
      const riftSlit = document.getElementById('rift-slit');
      const vignette = document.getElementById('vignette');

      // ============ CANVAS SETUP ============
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function createStars(count) {
        // Responsive star count based on screen size
        if (!count) {
          const targetCount = Math.min(1200, Math.floor((canvas.width * canvas.height) / 4500));
          count = targetCount;
        }
        stars = [];
        for (let i = 0; i < count; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            z: Math.random() * 1000,
            size: Math.random() * 1 + 0.2,
            brightness: Math.random() * 0.3 + 0.2
          });
        }
      }

      function drawStars() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2 + drift.x * 0.5;
        const centerY = canvas.height / 2 + drift.y * 0.5;

        stars.forEach(star => {
          star.z -= starSpeed * 6;
          if (star.z <= 0) {
            star.z = 1000;
            star.x = Math.random() * canvas.width;
            star.y = Math.random() * canvas.height;
          }

          const scale = 800 / star.z;
          const x = (star.x - centerX) * scale + centerX;
          const y = (star.y - centerY) * scale + centerY;
          const size = Math.max(0.3, star.size * scale * (starSpeed > 2 ? 1 + (starSpeed - 2) * 0.15 : 1));

          // Warm white color
          const warmR = 245, warmG = 242, warmB = 234;

          if (starSpeed > 2) {
            const prevZ = star.z + starSpeed * 6;
            const prevScale = 800 / prevZ;
            const prevX = (star.x - centerX) * prevScale + centerX;
            const prevY = (star.y - centerY) * prevScale + centerY;

            const grad = ctx.createLinearGradient(prevX, prevY, x, y);
            grad.addColorStop(0, `rgba(${warmR},${warmG},${warmB},0)`);
            grad.addColorStop(1, `rgba(${warmR},${warmG},${warmB},${star.brightness * 0.6})`);

            ctx.beginPath();
            ctx.strokeStyle = grad;
            ctx.lineWidth = size * 0.5;
            ctx.moveTo(prevX, prevY);
            ctx.lineTo(x, y);
            ctx.stroke();
          }

          ctx.beginPath();
          ctx.fillStyle = `rgba(${warmR},${warmG},${warmB},${star.brightness})`;
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        });

        // Slower interpolation for smoother feel
        starSpeed += (targetStarSpeed - starSpeed) * 0.04;
      }

      // ============ DRIFT SYSTEM ============
      function updateDrift() {
        if (keys.up) drift.vy -= driftSpeed;
        if (keys.down) drift.vy += driftSpeed;
        if (keys.left) drift.vx -= driftSpeed;
        if (keys.right) drift.vx += driftSpeed;

        drift.vx *= driftFriction;
        drift.vy *= driftFriction;

        drift.x += drift.vx;
        drift.y += drift.vy;

        drift.x = Math.max(-driftMax, Math.min(driftMax, drift.x));
        drift.y = Math.max(-driftMax, Math.min(driftMax, drift.y));

        const finalX = drift.x + mouseParallax.x * 12;
        const finalY = drift.y + mouseParallax.y * 12;

        driftContainer.style.transform = `translate(${finalX}px, ${finalY}px)`;
      }

      // ============ ANIMATION LOOP ============
      function animate() {
        drawStars();
        updateDrift();
        requestAnimationFrame(animate);
      }

      // ============ LAYER TRANSITIONS ============
      function updateLayerClass() {
        document.body.classList.remove('layer-1', 'layer-2', 'layer-3', 'layer-4');
        document.body.classList.add(`layer-${currentLayer}`);
      }

      function warpTransition(targetLayer) {
        if (isTransitioning || targetLayer < 1 || targetLayer > totalLayers || targetLayer === currentLayer) return;

        console.log(`[WARP] Layer ${currentLayer} -> ${targetLayer}`);
        isTransitioning = true;
        document.body.classList.add('transitioning');

        const currentEl = document.querySelector(`.layer[data-layer="${currentLayer}"]`);
        const targetEl = document.querySelector(`.layer[data-layer="${targetLayer}"]`);
        const currentContent = currentEl.querySelector('.layer-content');
        const targetContent = targetEl.querySelector('.layer-content');

        targetStarSpeed = warpStarSpeed;
        warpGlow.classList.add('active');
        vignette.classList.add('active');

        currentContent.classList.add('warp-out');
        currentEl.classList.add('transitioning');

        setTimeout(() => {
          warpGlow.classList.remove('active');
        }, 600);

        setTimeout(() => {
          currentEl.classList.remove('active');
          currentContent.classList.remove('warp-out');
          targetEl.classList.add('active', 'transitioning');
          targetContent.classList.add('warp-in');
          currentLayer = targetLayer;
          updateLayerClass();
        }, warpMidpoint);

        setTimeout(() => {
          targetContent.classList.remove('warp-in');
          currentEl.classList.remove('transitioning');
          targetEl.classList.remove('transitioning');
          vignette.classList.remove('active');
          targetStarSpeed = baseStarSpeed;
          isTransitioning = false;
          document.body.classList.remove('transitioning');
        }, warpDuration);
      }

      function riftFallTransition() {
        if (isTransitioning || currentLayer === 1) return;

        const options = [2, 3, 4].filter(l => l !== currentLayer);
        const targetLayer = options[Math.floor(Math.random() * options.length)];

        console.log(`[RIFT FALL] Layer ${currentLayer} -> ${targetLayer}`);
        isTransitioning = true;
        document.body.classList.add('transitioning');

        const currentEl = document.querySelector(`.layer[data-layer="${currentLayer}"]`);
        const targetEl = document.querySelector(`.layer[data-layer="${targetLayer}"]`);
        const currentContent = currentEl.querySelector('.layer-content');
        const targetContent = targetEl.querySelector('.layer-content');

        targetStarSpeed = fallStarSpeed;
        riftSlit.classList.add('active');
        vignette.classList.add('active');

        currentContent.classList.add('rift-out');
        currentEl.classList.add('transitioning');

        setTimeout(() => {
          riftSlit.classList.remove('active');
        }, 600);

        setTimeout(() => {
          currentEl.classList.remove('active');
          currentContent.classList.remove('rift-out');
          targetEl.classList.add('active', 'transitioning');
          targetContent.classList.add('rift-in');
          currentLayer = targetLayer;
          updateLayerClass();
        }, fallMidpoint);

        setTimeout(() => {
          targetContent.classList.remove('rift-in');
          currentEl.classList.remove('transitioning');
          targetEl.classList.remove('transitioning');
          vignette.classList.remove('active');
          targetStarSpeed = baseStarSpeed;
          isTransitioning = false;
          document.body.classList.remove('transitioning');
        }, fallDuration);
      }

      function gateTransition(href) {
        if (isTransitioning) return;

        console.log(`[GATE] Navigating to ${href}`);
        isTransitioning = true;
        document.body.classList.add('transitioning');

        targetStarSpeed = warpStarSpeed;
        warpGlow.classList.add('active');

        const layer = document.querySelector('.layer.active');
        const content = layer.querySelector('.layer-content');
        content.classList.add('warp-out');

        setTimeout(() => {
          window.location.href = href;
        }, 800);
      }

      // ============ EVENT HANDLERS ============
      document.addEventListener('keydown', (e) => {
        // Drift keys (do NOT change layers)
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { keys.up = true; e.preventDefault(); }
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { keys.down = true; e.preventDefault(); }
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { keys.left = true; e.preventDefault(); }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { keys.right = true; e.preventDefault(); }

        // Layer change keys
        if (e.key === 'Enter' && !e.repeat) {
          e.preventDefault();
          const nextLayer = (currentLayer % totalLayers) + 1;
          warpTransition(nextLayer);
        }

        if ((e.key === 'f' || e.key === 'F' || e.key === ' ') && !e.repeat) {
          e.preventDefault();
          if (currentLayer === 1) {
            warpTransition(2);
          } else {
            riftFallTransition();
          }
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
      });

      document.addEventListener('mousemove', (e) => {
        mouseParallax.x = (e.clientX / window.innerWidth - 0.5) * 2;
        mouseParallax.y = (e.clientY / window.innerHeight - 0.5) * 2;
      });

      document.addEventListener('click', (e) => {
        if (e.target.closest('[data-gate]')) return;

        const now = Date.now();
        if (now - lastClickTime < doubleClickThreshold) {
          if (currentLayer === 1) {
            warpTransition(2);
          } else {
            riftFallTransition();
          }
        }
        lastClickTime = now;
      });

      document.querySelectorAll('[data-gate]').forEach(gate => {
        gate.addEventListener('click', (e) => {
          e.preventDefault();
          gateTransition(gate.getAttribute('href'));
        });
      });

      // Mobile touch
      document.addEventListener('touchstart', (e) => {
        if (e.target.closest('[data-gate]')) return;

        touchStartTime = Date.now();
        longPressTimer = setTimeout(() => {
          if (currentLayer === 1) {
            warpTransition(2);
          } else {
            riftFallTransition();
          }
        }, longPressDuration);
      }, { passive: true });

      document.addEventListener('touchend', (e) => {
        if (e.target.closest('[data-gate]')) return;

        clearTimeout(longPressTimer);
        const duration = Date.now() - touchStartTime;

        if (duration < longPressDuration) {
          warpTransition(currentLayer + 1);
        }
      }, { passive: true });

      document.addEventListener('touchmove', () => {
        clearTimeout(longPressTimer);
      }, { passive: true });

      // ============ INIT ============
      resizeCanvas();
      createStars();
      updateLayerClass();
      animate();

      window.addEventListener('resize', () => {
        resizeCanvas();
        createStars();
      });

      console.log('[PORTAL] Initialized');
    </script>

    <!-- ============ AION INFINITY + PARTICLE TEXT SYSTEM ============ -->
    <script>
      /**
       * AION - Animated Infinity Symbol with Particle Text
       * 
       * Tuning Constants:
       */
      const INFINITY_SCALE = 0.65;           // Scale relative to min(viewportW, viewportH)
      const PARTICLE_COUNT_DESKTOP = 1100;   // Particle count for desktop
      const PARTICLE_COUNT_MOBILE = 500;     // Particle count for mobile (< 768px)
      const GLOW_INTENSITY = 0.8;            // Glow strength (0-1)
      const BREATH_PERIOD_MS = 14000;        // Breathing cycle in ms (10-20s)
      const NOISE_AMPLITUDE = 8;             // Organic wobble amount
      const SHIMMER_SPEED = 0.002;           // Particle shimmer rate

      class AionVisual {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.dpr = Math.min(window.devicePixelRatio || 1, 2);
          this.time = 0;
          this.particles = [];
          this.infinityPoints = [];
          this.aionTargets = [];
          
          // Colors
          this.warmWhite = { r: 245, g: 242, b: 234 };
          this.accentSilver = { r: 200, g: 210, b: 220 };
          this.accentGold = { r: 255, g: 240, b: 200 };
          this.accentIce = { r: 220, g: 240, b: 255 };
          
          this.resize();
          this.initParticles();
          this.generateAionTargets();
          this.animate();
          
          window.addEventListener('resize', () => this.resize());
        }

        resize() {
          const w = window.innerWidth;
          const h = window.innerHeight;
          this.width = w;
          this.height = h;
          this.canvas.width = w * this.dpr;
          this.canvas.height = h * this.dpr;
          this.canvas.style.width = w + 'px';
          this.canvas.style.height = h + 'px';
          this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
          
          this.centerX = w / 2;
          this.centerY = h / 2;
          this.baseSize = Math.min(w, h) * INFINITY_SCALE;
          
          // Regenerate targets on resize
          this.generateAionTargets();
        }

        initParticles() {
          const isMobile = window.innerWidth < 768;
          const count = isMobile ? PARTICLE_COUNT_MOBILE : PARTICLE_COUNT_DESKTOP;
          
          this.particles = [];
          for (let i = 0; i < count; i++) {
            this.particles.push({
              x: Math.random() * this.width,
              y: Math.random() * this.height,
              vx: (Math.random() - 0.5) * 0.5,
              vy: (Math.random() - 0.5) * 0.5,
              targetX: 0,
              targetY: 0,
              size: Math.random() * 1.5 + 0.5,
              alpha: Math.random() * 0.5 + 0.3,
              phase: Math.random() * Math.PI * 2,
              shimmerOffset: Math.random() * 1000,
              // Color accent (most are warm white, few have subtle accents)
              accent: Math.random() < 0.85 ? 0 : (Math.random() < 0.5 ? 1 : 2)
            });
          }
        }

        generateAionTargets() {
          // Generate target positions for "AION" text using points
          this.aionTargets = [];
          
          const fontSize = Math.min(this.width * 0.12, this.height * 0.08, 80);
          const letterSpacing = fontSize * 0.85;
          const totalWidth = letterSpacing * 3.5;
          const startX = this.centerX - totalWidth / 2;
          const textY = this.centerY + this.baseSize * 0.55; // Below infinity
          
          const letters = ['A', 'I', 'O', 'N'];
          
          letters.forEach((letter, idx) => {
            const letterX = startX + idx * letterSpacing;
            const points = this.getLetterPoints(letter, letterX, textY, fontSize);
            this.aionTargets.push(...points);
          });
          
          // Assign targets to particles
          const aionParticleCount = Math.min(this.aionTargets.length * 3, Math.floor(this.particles.length * 0.35));
          for (let i = 0; i < this.particles.length; i++) {
            if (i < aionParticleCount && this.aionTargets.length > 0) {
              const target = this.aionTargets[i % this.aionTargets.length];
              this.particles[i].targetX = target.x;
              this.particles[i].targetY = target.y;
              this.particles[i].isAion = true;
            } else {
              // Floating particles - no fixed target
              this.particles[i].targetX = null;
              this.particles[i].targetY = null;
              this.particles[i].isAion = false;
            }
          }
        }

        getLetterPoints(letter, cx, cy, size) {
          const points = [];
          const density = Math.max(8, Math.floor(size / 6));
          const half = size / 2;
          
          switch(letter) {
            case 'A':
              // Triangle shape with crossbar
              for (let i = 0; i < density; i++) {
                const t = i / density;
                // Left leg
                points.push({ x: cx - half + t * half, y: cy + half - t * size });
                // Right leg
                points.push({ x: cx + half - t * half, y: cy + half - t * size });
              }
              // Crossbar
              for (let i = 0; i < density * 0.6; i++) {
                const t = i / (density * 0.6);
                points.push({ x: cx - half * 0.4 + t * half * 0.8, y: cy + half * 0.1 });
              }
              break;
            case 'I':
              // Vertical line with serifs
              for (let i = 0; i < density; i++) {
                const t = i / density;
                points.push({ x: cx, y: cy - half + t * size });
              }
              // Top serif
              for (let i = 0; i < density * 0.4; i++) {
                const t = i / (density * 0.4);
                points.push({ x: cx - half * 0.3 + t * half * 0.6, y: cy - half });
              }
              // Bottom serif
              for (let i = 0; i < density * 0.4; i++) {
                const t = i / (density * 0.4);
                points.push({ x: cx - half * 0.3 + t * half * 0.6, y: cy + half });
              }
              break;
            case 'O':
              // Circle/ellipse
              for (let i = 0; i < density * 2; i++) {
                const angle = (i / (density * 2)) * Math.PI * 2;
                points.push({ 
                  x: cx + Math.cos(angle) * half * 0.5, 
                  y: cy + Math.sin(angle) * half 
                });
              }
              break;
            case 'N':
              // Two verticals with diagonal
              for (let i = 0; i < density; i++) {
                const t = i / density;
                // Left vertical
                points.push({ x: cx - half * 0.4, y: cy - half + t * size });
                // Right vertical
                points.push({ x: cx + half * 0.4, y: cy - half + t * size });
                // Diagonal
                points.push({ x: cx - half * 0.4 + t * half * 0.8, y: cy - half + t * size });
              }
              break;
          }
          return points;
        }

        // Organic noise for wobble effect
        noise(x, y, t) {
          return Math.sin(x * 0.01 + t) * Math.cos(y * 0.01 + t * 0.7) * NOISE_AMPLITUDE;
        }

        // Get point on infinity curve (lemniscate of Bernoulli)
        getInfinityPoint(t, breathScale) {
          const a = this.baseSize * 0.45 * breathScale;
          const denom = 1 + Math.sin(t) * Math.sin(t);
          const x = a * Math.cos(t) / denom;
          const y = a * Math.sin(t) * Math.cos(t) / denom;
          
          // Add organic noise
          const nx = this.noise(x, y, this.time * 0.5);
          const ny = this.noise(y, x, this.time * 0.5 + 100);
          
          return {
            x: this.centerX + x + nx,
            y: this.centerY + y + ny
          };
        }

        getBreathScale() {
          const phase = (this.time * 1000 / BREATH_PERIOD_MS) * Math.PI * 2;
          return 1 + Math.sin(phase) * 0.06;
        }

        render() {
          // Clear with transparency to show stars behind
          this.ctx.clearRect(0, 0, this.width, this.height);
          
          const breathScale = this.getBreathScale();
          const breathIntensity = 0.9 + Math.sin((this.time * 1000 / BREATH_PERIOD_MS) * Math.PI * 2) * 0.1;
          
          // Draw infinity symbol
          this.drawInfinity(breathScale, breathIntensity);
          
          // Update and draw particles
          this.updateParticles(breathScale);
          this.drawParticles(breathIntensity);
        }

        drawInfinity(breathScale, intensity) {
          this.ctx.save();
          
          // Multiple glow layers
          for (let glowPass = 0; glowPass < 3; glowPass++) {
            const alpha = (0.15 - glowPass * 0.04) * intensity * GLOW_INTENSITY;
            const lineWidth = (3 - glowPass * 0.8) * breathScale;
            
            this.ctx.beginPath();
            this.ctx.strokeStyle = `rgba(${this.warmWhite.r}, ${this.warmWhite.g}, ${this.warmWhite.b}, ${alpha})`;
            this.ctx.lineWidth = lineWidth;
            this.ctx.shadowColor = `rgba(${this.warmWhite.r}, ${this.warmWhite.g}, ${this.warmWhite.b}, ${0.5 * GLOW_INTENSITY})`;
            this.ctx.shadowBlur = 30 + glowPass * 20;
            
            // Draw infinity curve
            for (let t = 0; t <= Math.PI * 4; t += 0.05) {
              const p = this.getInfinityPoint(t, breathScale);
              if (t === 0) {
                this.ctx.moveTo(p.x, p.y);
              } else {
                this.ctx.lineTo(p.x, p.y);
              }
            }
            this.ctx.stroke();
          }
          
          // Draw flowing energy particles along the infinity
          this.ctx.globalCompositeOperation = 'screen';
          for (let i = 0; i < 60; i++) {
            const t = ((this.time * 0.3 + i * 0.15) % (Math.PI * 4));
            const p = this.getInfinityPoint(t, breathScale);
            const fade = Math.sin((i / 60) * Math.PI) * intensity;
            
            this.ctx.beginPath();
            this.ctx.fillStyle = `rgba(${this.warmWhite.r}, ${this.warmWhite.g}, ${this.warmWhite.b}, ${fade * 0.6 * GLOW_INTENSITY})`;
            this.ctx.shadowBlur = 15;
            this.ctx.arc(p.x, p.y, 2 * breathScale, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          this.ctx.restore();
        }

        updateParticles(breathScale) {
          this.particles.forEach(p => {
            if (p.isAion && p.targetX !== null) {
              // Drift toward target with some organic movement
              const dx = p.targetX - p.x;
              const dy = p.targetY - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              // Attraction force
              const attraction = 0.02;
              p.vx += dx * attraction;
              p.vy += dy * attraction;
              
              // Add subtle drift
              p.vx += Math.sin(this.time + p.phase) * 0.02;
              p.vy += Math.cos(this.time * 0.7 + p.phase) * 0.02;
            } else {
              // Free floating particles
              p.vx += (Math.random() - 0.5) * 0.05;
              p.vy += (Math.random() - 0.5) * 0.05;
              
              // Gentle drift toward center area
              const toCenterX = (this.centerX - p.x) * 0.0003;
              const toCenterY = (this.centerY - p.y) * 0.0003;
              p.vx += toCenterX;
              p.vy += toCenterY;
            }
            
            // Friction
            p.vx *= 0.96;
            p.vy *= 0.96;
            
            // Update position
            p.x += p.vx;
            p.y += p.vy;
            
            // Wrap around edges
            if (p.x < -50) p.x = this.width + 50;
            if (p.x > this.width + 50) p.x = -50;
            if (p.y < -50) p.y = this.height + 50;
            if (p.y > this.height + 50) p.y = -50;
          });
        }

        drawParticles(intensity) {
          this.ctx.save();
          this.ctx.globalCompositeOperation = 'screen';
          
          this.particles.forEach(p => {
            // Shimmer effect
            const shimmer = Math.sin(this.time * SHIMMER_SPEED * 1000 + p.shimmerOffset) * 0.3 + 0.7;
            const alpha = p.alpha * shimmer * intensity * GLOW_INTENSITY;
            
            // Color based on accent
            let color;
            if (p.accent === 0) {
              color = this.warmWhite;
            } else if (p.accent === 1) {
              color = this.accentSilver;
            } else {
              color = this.accentIce;
            }
            
            this.ctx.beginPath();
            this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
            this.ctx.shadowColor = `rgba(${this.warmWhite.r}, ${this.warmWhite.g}, ${this.warmWhite.b}, ${alpha * 0.5})`;
            this.ctx.shadowBlur = 8;
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
          });
          
          this.ctx.restore();
        }

        animate() {
          this.time += 1/60;
          
          // Only render if on layer 1
          if (document.body.classList.contains('layer-1')) {
            this.render();
          }
          
          requestAnimationFrame(() => this.animate());
        }
      }

      // Initialize AION when page loads
      const aionCanvas = document.getElementById('aion-canvas');
      if (aionCanvas) {
        new AionVisual(aionCanvas);
        console.log('[AION] Initialized');
      }
    </script>
  </body>
</html>